[["index.html", "MATH 479 Network Science Project Preface", " MATH 479 Network Science Project Zhaoheng Li and Zuofu Huang, Fall 2020 Macalester College Preface Hello! Welcome to our final project of Network Science! This bookdown is a work in progress, and please check back early and often (as much as people do to their Github code). Feel free to contact us if you have any questions! Now that we are in the realm of networks, we feel compelled to motivate our project with an xkcd comic related to networks. Credit to xkcd: https://xkcd.com/350/ "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction We are motivated by existing genetic association studies that find the correlation between certain diseases/traits and genetic variants (SNP mutations). We wonder if network analysis can be utilized in the process of genome-wide association studies. Genome wide association studies (GWAS) is a method for identifying the associations between certain genetic regions called loci and one’s trait. Usually among the traits, we are interested in the disease status. Later, we came across the paper named Network Analysis of GWAS data (Leiserson et. al, 2013), where we first saw the connection made between genetics and network science. This motivates our attempt of finding genetic pathway interactions for a certain disease/trait. Intuitively, we would like to think of the simplified scenario: a certain disease can be caused by several genetic pathways. Suppose we have \\(n\\) SNP locations previously identified as related to the disease, and \\(k\\) subsets among the SNP locations that in combination cause the disease (\\(k &lt; n\\)). Our goal is to simulate data that aligns with the proposed setting, and use network science tools to identify these pathway interactions (pretending that we did not know the underlying true subsets). This process aims at testing the validity of the network science tool we propose. Looking forward, we would like to test how the tool behaves when the dataset we simulate contains genetic information for two diseases: we wonder if the algorithm is capable of picking up pathway interaction patterns for both diseases. "],["initial-steps.html", "Chapter 2 Initial Steps 2.1 Genetics Background 2.2 Simulate original data 2.3 Sample mutations for patients at SNP locations 2.4 Sample mutations for non-patients at SNP locations 2.5 Variants at non-SNP locations 2.6 Screening 2.7 Marginal Regression 2.8 Discussion", " Chapter 2 Initial Steps Our initial thought was that Genome-Wide Association Studies data is readily available for public access and that we should be able to retrieve the dataset easily. However, it came unexpected that a research proposal from faculty was needed to obtain GWAS data for research purposes. Therefore, we decide to simulate our own GWAS data for the purpose of this research. 2.1 Genetics Background The human genome contains roughly 234,000 exons, 80% of which contain fewer than 200 base pairs in length. However, mutations in these exons contain a majority of mutations that are related to diseases. Our setting is structured in this context. Suppose we have a disease. It is reasonable to assume that we know where the mutations related to this disease approximately are along the genome. We guess that 1000 loci (specific position where a gene is located) could harbor the disease-related mutations. In addition, we assume that each locus on average contains 200 base pairs (a pair of complementary bases in a double-stranded DNA: A-T, G-C), which corresponds to locus_length &lt;- 200 in the code. loci &lt;- 1000 locus_length &lt;- 200 2.2 Simulate original data We start by creating the dataset. Everyone row is set to the reference level first (i.e. there is no variant). Suppose initially we have 500 individuals, and we categorize 100 as people who have the disease. n &lt;- 500 n_disease &lt;- 100 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = loci*locus_length, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = loci * locus_length,byrow = TRUE)) SNP_location &lt;- sample(1:(loci*locus_length), size = 50, replace = FALSE) reference_level_SNP_location &lt;- reference[SNP_location] 2.3 Sample mutations for patients at SNP locations We then sample mutations at SNP locations who were categorized at patients. disease_people_row_number &lt;- sample(1:500, 100, replace = FALSE) combo_number &lt;- 15 SNP_number &lt;- sample(1:6, combo_number, replace = TRUE) disease_combo &lt;- list() for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) #helper functions for decomposition. helper2 &lt;- function(char){ other_set &lt;- setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;G&quot;,&quot;C&quot;),char) return(sample(other_set,1)) } helper3 &lt;- function(char, p = 0.15){ random &lt;- runif(1) if (random &lt;= (1-3*p)){ return(char) } else if (random &lt;= 1-2*p){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[1]) } else if (random &lt;= (1-p)){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[2]) } else { return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[3]) } } # For patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper2(reference_level_SNP_location[index[j]]) } # non-disease-related SNP mutations non_forced_index &lt;- setdiff(1:50, index) for (k in 1:length(non_forced_index)){ reference_level_SNP_location_copy[non_forced_index[k]] &lt;- helper3(reference_level_SNP_location[non_forced_index[k]],0.15) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy } 2.4 Sample mutations for non-patients at SNP locations We then hypothesize that given a common condition, non-patients are also more likely to have mutations at the SNP locations than at most other locations (e.g. those locations that make human human). # For those who are not set to have disease first (400) # Loop over 50 genes, each one has some possibility to mutate. (More likely than the other nucleotides on the genome) non_disease_row_number &lt;- setdiff(1:500,disease_people_row_number) for (i in non_disease_row_number){ for (j in SNP_location) data[i,j] &lt;- helper3(data[i,j],0.05) } 2.5 Variants at non-SNP locations The next step is simulating random noise at non-SNP locations to better mimic properties of gene mutations in real life. potential_SNP_places &lt;- SNP_location potential_random_change_sites &lt;- setdiff(1:(loci*locus_length),SNP_location) for (i in 1:n){ random_locus &lt;- sample(potential_random_change_sites, size = (loci*locus_length/1000), replace = FALSE) # definitely change for(j in random_locus){ data[i,j] &lt;- helper2(data[i,j]) potential_SNP_places &lt;- c(potential_SNP_places, random_locus) } } potential_SNP_places &lt;- unique(potential_SNP_places) 2.6 Screening With the mutations that non-patients had at SNP locations, some of the 400 people may fall into the “disease” status. We then performed a round of screening for 400 people who were initially categorized without the disease. Surprisingly, we found that a large number of people fall into the “disease” status. We were surprised for two reasons: The probability of mutations at each location is low. Even if many mutations happen for someone, a right “combination of pathways” is needed to achieve the “disease” status, which happens more often than estimated. # Do a round of screening for 400 people who did not initially have the disease NewPatient &lt;- c() for (i in non_disease_row_number){ MutatedSNP &lt;- c() for(j in SNP_location){ if(isMutated(i,j)){ MutatedSNP &lt;- c(MutatedSNP,j) } } for(k in 1:15){ if(all(disease_combo[[k]] %in% MutatedSNP)){ causalPathway &lt;- c() for(position in disease_combo[[k]]){ causalPathway = c(causalPathway,helper2(reference[position])) } if(all(data[i,position] == causalPathway)){ NewPatient &lt;- c(NewPatient,i) break } } } } disease_row_final &lt;- c(disease_people_row_number, NewPatient) disease_status_vector &lt;- rep(FALSE, 500) for (i in 1:500){ if (i %in% disease_row_final){ disease_status_vector[i] &lt;- TRUE } } 2.7 Marginal Regression Once we have simulated potential variants for everyone at every location, we find all places that at least one person has a variation at, select the places and fit a marginal regression at each location against the disease status. for (i in potential_SNP_places){ reference_level_here &lt;- reference[i] for (j in 1:n){ if (data[j,i] == reference_level_here){ data[j,i] &lt;- TRUE } else { data[j,i] &lt;- FALSE } } } subdata &lt;- data[,potential_SNP_places] isMutated &lt;- function(person,position){ if(data[person,position] == reference[position] ){ return(FALSE) } else{ return(TRUE) } } for (i in potential_SNP_places){ summary(lm(disease_status_vector ~ data[,i])) } 2.8 Discussion Problems with this approach, as we realized later, were that: We assumed genetic variants were the only reason people caused the disease, which was almost never the case. People who were initially categorized as non-patients and later changed their status are more than we expected. This casts doubt on the necessity of pre-determining the number of patients (100 in this case). Our approach was not fully supported by pre-existing literature. We pasted pieces of several literature into this approach. The probability of mutations at each location was also not documented. When we are simulating random variants, we set the number of changes to be size = (loci*locus_length/1000) as we believed the average probability of SNP is 1/1000. However, this is faulty because the size was fixed at the expected value of the number of mutation sites, without allowing any difference across individuals. Let \\(\\text{X = number of variants}\\) and \\(\\text{n = number of locations}\\). \\(X\\) follows the distribution: \\(X \\sim Bin(n,p)\\). However, \\(X\\) can vary as we draw from the Binomial distribution. With the reasons above, we keep digging into the literature and tested potential alternatives. "],["progress-and-revision.html", "Chapter 3 Progress and Revision 3.1 Rationale 3.2 Updated Code", " Chapter 3 Progress and Revision 3.1 Rationale When we found out that only SNP locations can be categorized as significant and other loci are exclusively “non-significant”, we realized that we are getting too far into simulation. Although it seemed that every step we take is justified, the simulated data seem unrealistic and overfitting for our scenario. As we were conduting a more extensive literature review process in the hope of shedding light on our next simulation steps, we came across the paper Discovery of Mutated Subnetworks Associated with Clinical Data in Cancer (Vandin et. al, 2012). Section 3.1 of the paper contains a description of how the data is simulated in a slightly different setting. There are a few notable changes that we implemented in the Progress and Revision section. We argue that a common disease can be caused by both genetic variants and external environmental factors, as opposed to the genetic variations alone in our previous simulations. Therefore, we can pre-determine the number of people whose diseases are caused by genetic factors (as the paper suggested, 20% of people who carry the disease). The value of \\(p\\) is determined by the biological background that on average the probability of having a mutation at each location is \\(1/1000\\), as described in “What Are Single Nucleotide Polymorphisms (SNPs)?” (n.d.). For people whose diseases are caused by genetic factors: the probability of mutations at every other location (including SNP locations that were not in their combination) has a probability of \\(p = 1/1000\\). For people whose diseases are caused by non-genetic factors: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For people who do not have the disease: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For the purpose of the simulation, we combine the group of people whose disease are caused by non-genetic factors and the group of people who do not carry the disease. Suppose we have a total of 500 people, half of which do not carry the disease. Then the total number of people whose disease are caused by genetic factors is 10% of the total population, as seen in n_disease &lt;- 0.1n in the Update Code section below. We determine that there are 4 combinations of genetic pathways that cause the disease (which is much more realistic than 15 pathways). Each of the pathway contains a random group of 4-5 variants chosen from 15 SNP locations. The variant could be present in more than one pathway or none of the pathways. We replace the multiplication of loci and locus_length with a total positions of 3000. We argue that reducing the number of loci at first does not change our inference process. As we test the validity of the approach, we then have the freedom of increasing the dimension (column) of the dataset or incorporating another disease/trait and the corresponding genetic pathways in our analysis. 3.2 Updated Code n &lt;- 500 n_disease &lt;- n*0.1 total_position &lt;- 3000 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = total_position, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = total_position,byrow=TRUE)) disease_people_row_number &lt;-seq(1,n_disease) non_disease &lt;- seq((n_disease+1),n) combo_number &lt;- 4 disease_combo &lt;- list() SNP_number &lt;- sample(4:5, combo_number, replace = TRUE) SNP_location &lt;- sample(1:total_position, 15, replace = FALSE) for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } reference_level_SNP_location &lt;- reference[SNP_location] disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) helper &lt;- function(char){ return(sample(setdiff(c(&quot;A&quot;,&quot;C&quot;,&quot;T&quot;,&quot;G&quot;),char),1)) } # function to mutate positions not in the identified pathways mutater &lt;- function(vec,non_position){ mutated &lt;- c() for (i in 1:length(vec)){ if (! i %in% non_position){ rand &lt;- runif(1) if (rand &lt;= 10^{-3}){ vec[i] &lt;- helper(vec[i]) mutated &lt;- c(mutated, i) } } } return(list(vec,mutated)) } # all mutated positions mutated_position &lt;- SNP_location # keep track of mutated positions for each subject # to record co-occurrence frequency of mutations # For causal-pathway-related patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper(reference_level_SNP_location[index[j]]) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy # random change mutated_result &lt;- mutater(data[i,],thiscombo) data[i,] &lt;- mutated_result[[1]] # update the list of all positions that mutated mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } # for everyone else for (k in (n_disease+1):n){ # update mutated positions mutated_result &lt;- mutater(data[k,], SNP_location) data[k,] &lt;- mutated_result[[1]] mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } mutated_position &lt;- unique(mutated_position) # Delete the locations among the 15 pre-identified locations that are not selected to be part of a causal pathway del &lt;- c() for(p in mutated_position){ count &lt;- 0 if(all(data[,p]==reference[p])){ del &lt;- c(del,p) } } mutated_position &lt;- setdiff(mutated_position,del) # Create a subset of the data for all positions with at least one mutation for(position in mutated_position){ # return true if a mutation happens at the position data[,position] &lt;- !(data[,position]==reference[position]) } sub_data &lt;- data[,mutated_position] position &lt;- colnames(sub_data) Create the adjacency matrix A that contains all positions where there is at least one mutation across all subjects. A = matrix(0,length(mutated_position),length(mutated_position)) rownames(A) = colnames(sub_data) colnames(A) = colnames(sub_data) for(i in 1:nrow(sub_data)){ count = sum(sub_data[i,]==TRUE) if(count&gt;=2){ loc = which(as.logical(as.vector(sub_data[i,])),TRUE) pairs_mat = combn(loc,2) for(j in 1:ncol(pairs_mat)){ r = pairs_mat[1,j] c = pairs_mat[2,j] A[r,c] = A[r,c]+1 } } } A &lt;- as.matrix(forceSymmetric(A,&quot;U&quot;)) Calculate the degree of the adjacency matrix. We can understand more of the matrix by calculating the average degree. deg &lt;- rowSums(A) deg ## X124 X1049 X1108 X489 X69 X1593 X2734 X2732 X1327 X2163 X1992 X2171 X1406 ## 268 77 119 135 119 58 119 207 72 58 58 191 6 ## X1704 X802 X638 X1488 X2177 X2700 X941 X1826 X2962 X1152 X1694 X2012 X2355 ## 5 4 8 9 10 13 12 6 6 8 8 13 8 ## X112 X2624 X2297 X2551 X417 X2104 X2729 X1880 X97 X101 X1131 X2127 X2702 ## 6 9 5 5 10 10 11 4 11 12 17 10 10 ## X2953 X387 X960 X1633 X1442 X1719 X2659 X1595 X1975 X2778 X990 X1274 X2848 ## 10 6 6 8 11 7 8 7 14 7 5 9 8 ## X832 X1120 X1552 X2102 X2250 X2694 X23 X891 X1170 X2990 X615 X1542 X2761 ## 7 10 7 15 6 6 8 8 8 8 6 9 8 ## X61 X130 X808 X1082 X1480 X1616 X2505 X2637 X2642 X513 X1275 X1321 X273 ## 9 9 9 17 10 9 6 6 9 9 6 6 11 ## X719 X726 X2053 X2226 X2688 X2662 X2952 X1081 X1508 X1540 X2815 X39 X1176 ## 13 9 9 9 13 6 5 8 12 13 13 7 7 ## X2386 X121 X847 X1422 X2527 X2672 X1514 X1618 X2313 X2988 X68 X169 X997 ## 10 9 9 11 9 18 5 5 5 5 10 10 10 ## X2004 X2280 X2529 X2538 X553 X881 X1159 X1288 X1105 X1109 X1978 X2291 X2380 ## 13 13 10 10 7 7 14 9 10 10 10 10 10 ## X2862 X283 X842 X940 X2948 X1531 X2562 X336 X1127 X1146 X1611 X2309 X716 ## 10 8 8 8 8 5 5 14 12 8 12 8 10 ## X1374 X1809 X1876 X2002 X2987 X1831 X1945 X2665 X118 X2749 X1181 X1567 X2411 ## 10 10 10 10 14 7 7 9 9 6 6 8 6 ## X202 X1440 X1458 X1758 X167 X880 X295 X2016 X2985 X581 X2860 X120 X531 ## 9 10 10 10 6 9 12 5 7 7 5 6 10 ## X1383 X647 X564 X1580 X2233 X607 X2317 X2566 X2850 X2067 X2941 X706 X729 ## 6 5 10 6 6 3 6 5 3 1 1 6 6 ## X1291 X1444 X1519 X2051 X2503 X1094 X2206 X409 X1206 X2492 X1962 X2402 X80 ## 6 6 6 9 6 3 1 4 2 5 1 4 1 ## X2335 X1431 X1507 X1705 X2376 X2477 X2689 X256 X2576 X1003 X1024 X2208 X2181 ## 2 5 9 5 5 5 5 1 2 6 2 2 1 ## X2341 X259 X765 X2169 X1475 X2021 X2911 X356 X384 X2803 X702 X745 X784 ## 1 2 2 2 3 2 2 2 2 2 3 5 3 ## X2616 X1349 X1803 X2146 X430 X555 X2166 X2256 X2829 X2234 X2328 X2874 X457 ## 3 2 4 0 0 5 11 3 3 2 2 3 12 ## X655 X1510 X1601 X2512 X2711 X1362 X2555 X2640 X1790 X2320 X2824 X7 X88 ## 7 3 4 3 8 5 2 2 5 4 2 9 8 ## X173 X1259 X1271 X1703 X2262 X942 X998 X1957 X1655 X482 X1361 X2228 X2415 ## 6 8 6 15 10 6 3 3 1 5 3 6 7 ## X137 X371 X720 X2239 X2340 X2627 X2784 X1257 X1566 X1650 X2611 X2887 X2920 ## 7 6 6 6 6 6 11 8 5 5 5 5 5 ## X838 X2097 X2125 X2210 X2483 X46 X376 X1856 X2405 X38 X2908 X1951 X2392 ## 9 4 4 4 13 3 6 3 3 1 1 2 1 ## X450 X1786 X1864 X2861 X398 X552 X795 X1034 X1295 X1437 X2121 X470 X2057 ## 8 6 3 3 6 6 6 6 6 10 7 2 5 ## X2377 X2182 X2212 X1713 X1404 X2092 X2143 X408 X697 X2375 X2540 X2795 X198 ## 2 1 8 0 6 3 3 9 5 4 4 4 4 ## X51 X2167 X445 X2507 X2687 X736 X1167 X1194 X347 X1875 X2189 X2598 X922 ## 7 2 1 1 0 2 5 2 5 5 3 3 0 ## X12 X771 X1358 X928 X1377 X2274 X2691 X707 X1347 X2060 X2395 X1363 X1369 ## 3 3 3 4 4 4 4 0 10 3 3 4 2 ## X1942 X2219 X2350 X1145 X2471 X1614 X2081 X2571 X179 X432 X569 X948 X1390 ## 4 1 1 1 1 2 2 5 10 5 5 5 5 ## X1525 X81 X230 X1561 X1873 X1384 X2914 X2463 X281 X315 X2205 X262 X514 ## 7 8 3 4 3 1 1 0 2 4 2 5 3 ## X877 X1690 X602 X1290 X1901 X2552 X2979 X1484 X499 X1366 X1578 X1029 X2443 ## 3 3 5 5 5 5 8 1 2 2 2 4 0 ## X852 X1426 X2797 X50 X861 X1675 X2096 X2618 X2192 X282 X463 X653 X898 ## 2 12 5 9 4 6 6 4 0 9 8 6 6 ## X1343 X2094 X2844 X474 X920 X2071 X2306 X2427 X2336 X589 X2660 X2775 X595 ## 6 6 8 3 5 3 3 1 0 2 1 1 7 ## X1412 X395 X2038 X2892 X2334 X2617 X2966 X1668 X757 X1465 X2610 X2939 X923 ## 0 3 7 13 3 3 3 5 3 8 3 4 2 ## X2085 X2137 X980 X1774 X2800 X226 X964 X2286 X2921 X1294 X1818 X610 X949 ## 2 9 3 3 3 3 4 3 4 1 9 2 2 ## X2431 X1604 X1813 X1010 X2349 X2750 X2022 X2901 X912 X1247 X2123 X2774 X2957 ## 6 2 3 3 3 3 1 4 8 5 7 5 7 ## X53 X753 X760 X1043 X175 X631 X2643 X2381 X931 X1551 X32 X277 X390 ## 6 7 3 3 2 8 5 0 5 12 5 5 8 ## X855 X2084 X2521 X367 X534 X1379 X1452 X1663 X2864 X4 X1944 X2324 X2690 ## 5 5 5 14 8 10 8 9 8 5 5 5 5 ## X2319 X247 X1116 X1250 X1298 X2909 X1420 X1925 X2816 X2024 X2361 X2712 X1889 ## 0 4 6 4 8 4 3 5 3 3 6 1 11 ## X2301 X2525 X2587 X2656 X110 X1193 X1403 X2620 X587 X288 X345 X1920 X862 ## 4 4 6 4 6 3 7 3 4 3 3 3 1 ## X2197 X1076 X1785 X1902 X2054 X2185 X2634 X2789 X2916 X1816 X2365 X1606 X1894 ## 5 6 9 10 6 6 6 6 2 1 1 1 3 ## X2128 X1254 X2244 X725 X1012 X718 X2352 X306 X1260 X1375 X1628 X2369 X2439 ## 3 8 5 1 1 2 2 11 7 10 9 7 9 ## X2683 X2798 X1615 X146 X1018 X2343 X2744 X674 X809 X2453 X2465 X1008 X744 ## 7 7 0 3 6 3 9 3 3 3 3 0 2 ## X2514 X1662 X10 X523 X2030 X845 X883 X2302 X292 X2995 X1564 X2558 X56 ## 2 1 6 3 6 3 3 3 2 2 10 4 4 ## X385 X455 X519 X17 X2238 X74 X1063 X1128 X1639 X1837 X2014 X2157 X1535 ## 4 9 4 1 1 1 1 11 5 9 5 5 1 ## X835 X1306 X204 X305 X1179 X1265 X1625 X1692 X649 X805 X1866 X2517 X1224 ## 1 1 4 4 4 2 2 2 4 11 5 4 2 ## X2290 X622 X975 X1089 X579 X1649 X1308 X2894 X47 X79 X213 X676 X2159 ## 2 7 3 9 3 5 1 1 11 4 4 4 10 ## X359 X723 X1380 X2451 X1226 X2403 X1607 X2018 X2318 X2287 X94 X1735 X2932 ## 4 4 12 4 2 2 3 3 4 1 2 2 2 ## X403 X1104 X1571 X1572 X1910 X2043 X2322 X485 X991 X2435 X453 X90 X461 ## 7 11 7 10 7 7 7 6 2 2 0 4 4 ## X1686 X1697 X1890 X49 X930 X1990 X2548 X727 X1448 X585 X1284 X1738 X1911 ## 4 7 0 3 4 3 3 2 2 2 2 3 5 ## X2432 X2485 X1318 X520 X1011 X2544 X2991 X1166 X1287 X1939 X1598 X957 X2037 ## 5 3 2 3 3 3 3 3 4 3 1 2 2 ## X1541 X1717 X1084 X1310 X1487 X1852 X207 X274 X698 X2141 X2326 X1272 X1476 ## 3 3 4 4 4 4 6 4 4 7 1 1 1 ## X505 X1977 X2733 X2252 X560 X844 X1557 X16 X396 X2130 X2284 X2677 X584 ## 4 6 1 2 4 4 4 5 5 5 5 8 2 ## X962 X2725 X1330 X1191 X2958 X1123 X397 X1064 X1702 X139 X717 X2508 X307 ## 2 4 1 1 1 1 3 6 10 5 5 5 2 ## X2565 X1478 X1762 X2080 X2173 X2246 X571 X2480 X1311 X1411 X2200 X859 X1006 ## 2 7 7 7 7 7 2 3 2 2 2 2 2 ## X743 X1373 X1563 X2561 X2762 X1050 X1346 X947 X1946 X252 X2063 X1844 X2490 ## 2 2 6 3 3 3 3 5 4 2 2 5 1 ## X443 X248 X1940 X1322 X1602 X176 X1777 X1651 X2299 X57 X464 X682 X1100 ## 1 1 1 0 0 1 1 6 7 5 5 5 5 ## X2769 X967 X1948 X2706 X2984 X641 X1919 X2881 X1139 X1066 X1388 X1947 X116 ## 5 3 5 3 3 2 2 5 4 2 2 2 1 ## X2000 X1586 X2008 X2368 X180 X776 X2293 X2655 X351 X827 X1138 X996 X2372 ## 1 3 3 3 1 3 4 1 4 6 2 4 2 ## X2408 X1652 X2572 X43 X582 X2090 X19 X1143 X1669 X123 X658 X2869 X1934 ## 2 1 1 0 2 2 8 6 3 1 1 1 0 ## X156 X100 X1798 X1865 X427 X1019 X1185 X1088 X639 X1612 X2331 X1356 X2717 ## 0 7 3 3 3 3 3 1 2 2 2 1 2 ## X779 X2214 X2859 X2967 X460 X2810 X1900 X2078 X2145 X2893 X76 X613 X1208 ## 6 7 6 6 2 1 3 3 3 3 2 2 2 ## X246 X444 X1069 X2277 X2533 X344 X1728 X2599 X600 X791 X2042 X2357 X163 ## 1 5 3 3 3 7 2 2 3 3 3 3 6 ## X465 X1080 X1796 X197 X441 X1814 X565 X2731 X747 X521 X780 X1037 X1985 ## 3 4 3 7 2 2 2 2 0 0 2 3 3 ## X2100 X1725 X1160 X1950 X414 X624 X1794 X2329 X578 X937 X1689 X833 X2168 ## 3 1 1 1 4 4 4 5 8 2 2 2 2 ## X2183 X872 X929 X1765 X2288 X807 X1808 X1986 X2406 X2412 X2584 X1051 X1153 ## 2 3 3 8 2 6 6 8 6 6 6 2 2 ## X1439 X1493 X2745 X1733 X1824 X1433 X1924 X1449 X2975 X289 X530 X970 X2147 ## 2 1 4 1 1 0 5 1 1 6 6 6 6 ## X2570 X2978 X83 X774 X2468 X1754 X686 X2196 X2452 X2891 X2763 X386 X2457 ## 6 11 3 3 3 1 3 3 3 3 1 3 3 ## X2924 X1953 X2013 X2493 X1147 X750 X857 X1137 X2026 X623 X642 X830 X366 ## 3 0 6 1 1 3 3 3 3 4 4 1 2 ## X1982 X2148 X871 X1718 X2556 X438 X30 X144 X1608 X2792 X73 X1503 X1056 ## 2 2 0 1 1 3 2 2 2 0 3 3 5 ## X1125 X1338 X2664 X2720 X2817 X2440 X1999 X332 X1748 X1918 X2300 X2504 X2813 ## 11 6 5 5 5 3 3 5 12 10 8 5 5 ## X1203 X326 X150 X229 X532 X1016 X1331 X78 X1634 X2450 X2673 X2814 X242 ## 10 0 6 6 6 8 2 6 11 6 6 6 2 ## X1592 X664 X1103 X1239 X1988 X767 X1589 X1891 X2609 X2516 X619 X1232 X515 ## 2 7 5 4 4 4 4 4 4 1 1 1 2 ## X1749 X142 X889 X899 X1632 X2111 X2107 X2593 X1482 X2730 X84 X312 X932 ## 2 1 3 3 3 3 2 2 2 0 1 1 1 ## X1047 X165 X475 X651 X109 X428 X2312 X1283 X525 X2454 X2582 X2787 X1443 ## 1 5 2 2 4 5 4 1 5 5 5 5 2 ## X1569 X2580 X1804 X2384 X2422 X2460 X536 X1355 X2122 X2950 X596 X925 X1767 ## 2 0 12 6 3 0 2 2 2 0 5 11 5 ## X1776 X2790 X119 X2649 X75 X562 X1353 X2857 X2936 X1268 X2788 X487 X1723 ## 5 7 2 2 7 4 4 4 4 2 1 2 2 ## X2283 X1858 X2573 X2604 X1658 X2791 X316 X849 X963 X2088 X1851 X1883 X2366 ## 2 2 2 2 0 0 4 5 4 4 4 4 4 ## X2845 X1059 X1834 X2017 X2567 X1065 X1609 X1750 X2260 X966 X1240 X1969 X2447 ## 4 6 6 6 6 3 3 3 5 3 3 3 3 ## X1351 X1387 X2478 X1187 X1335 X1801 X250 X1605 X2639 X2666 X2680 X308 X1973 ## 3 3 3 2 2 1 5 7 5 5 5 3 3 ## X2385 X689 X1897 X2041 X2543 X2674 X636 X1833 X1862 X1888 X1554 X2693 X1627 ## 3 5 7 5 10 5 4 4 4 4 3 3 2 ## X2442 X251 X360 X2770 X2396 X2133 X2257 X300 X1960 X2209 X2959 X1631 X135 ## 1 5 5 5 2 2 2 3 3 3 3 3 4 ## X1610 X2135 X1337 X184 X1391 X2590 X2805 X1740 X2622 X15 X339 X951 X1528 ## 4 4 1 3 3 3 5 3 3 6 6 6 6 ## X1727 X1396 X865 X2131 X1102 X2101 X2241 X1562 X1577 X788 X2077 X2188 X648 ## 6 2 2 2 2 2 3 1 1 4 4 4 3 ## X2794 X2895 X2581 X2588 X1574 X2059 X2370 X823 X1967 X1532 X1714 X2546 X2676 ## 3 3 1 1 3 3 3 2 2 4 8 4 4 ## X2867 X2198 X1136 X2248 X2346 X935 X2251 X2498 X2724 X2738 X21 X680 X2180 ## 4 0 4 4 4 4 5 4 4 4 2 2 2 ## X91 X2086 X2112 X93 X2495 X1090 X1799 X1995 X1753 X1806 X2296 X1204 X1568 ## 4 4 4 1 1 2 2 2 3 3 3 4 4 ## X2531 X794 X1711 X1821 X2061 X261 X1555 X1795 X677 X1583 X657 X1244 X1673 ## 4 1 4 4 4 2 2 2 1 2 2 2 2 ## X2129 X413 X1135 X2195 X853 X1980 X2766 X145 X1696 X350 X153 X1895 X2641 ## 2 2 2 2 3 3 3 1 1 1 7 7 7 ## X2819 X2153 X2947 X82 X189 X876 X2015 X399 X477 X971 X2897 X436 X656 ## 7 2 2 2 2 3 3 4 4 4 2 13 4 ## X739 X2414 X836 X848 X1929 X627 X993 X406 X2884 X782 X1520 X1896 X187 ## 4 1 3 3 3 3 3 1 1 4 4 4 9 ## X989 X1474 X1515 X2619 X35 X2136 X732 X1886 X2010 X2907 X586 X843 X900 ## 9 9 9 9 5 5 4 4 4 4 3 3 3 ## X2390 X979 X1357 X796 X2285 X953 X320 X2310 X2387 X2986 X1074 X1849 X2265 ## 3 1 0 1 1 1 4 4 4 4 4 4 4 ## X2681 X141 X418 X789 X1023 X1679 X2404 X446 X1958 X2520 X25 X580 X1661 ## 4 6 6 6 6 6 6 2 2 2 0 3 3 ## X1667 X2330 X102 X375 X2316 X544 X1245 X2491 X2965 X1211 X1926 X2902 X1603 ## 3 2 3 3 3 0 1 2 2 3 1 1 0 "],["network-construction.html", "Chapter 4 Network Construction 4.1 Network Construction Process 4.2 Analysis 4.3 Centrality Measures Report 4.4 Preliminary Conclusions", " Chapter 4 Network Construction 4.1 Network Construction Process Below are the steps for calculating the “gene score” of each location that quantifies the degree of association between a base position and the disease/trait of interest. A higher score means a stronger association. For each position \\(g\\), we performed marginal regression and obtain a p-value, \\(p_g\\). Every position then is assigned a score \\(\\sigma(g) = -2log(p_g)\\) (Vandin et al., 2012). Two positions share an edge if they occur together, and the edge weight is their co-occurrence number. # record p values for each position mutations_pVal = c() disease_status_vector = c(rep(1,n/2),rep(0,n/2)) # Arbitrarily assign the first half with disease for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_vector&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) mutations_pVal = c(mutations_pVal,summary(model)$coefficient[,4][2]) } # compute score for each mutated position mutations_score &lt;- -2*log(mutations_pVal) edges = melt(A) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;%mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type, Weight) %&gt;% filter(Weight != 0) nodes = as.data.frame(colnames(sub_data))%&gt;%mutate(Lable= colnames(sub_data)) colnames(nodes) = c(&quot;Id&quot;,&quot;Lable&quot;) A.dat = as.data.frame(A) 4.2 Analysis After revising our simulation methodology, we simulated using 3000 base positions and 500 samples to obtain the following graphs. 12 of the 15 previously identified SNP locations are chosen to be part of at least one genetic pathway: X520, X521, X526, X1237, X1320, X1533, X1627, X2075, X2106, X2699, X2766, and X2881. These 12 effective SNP locations form 4 causal pathways that lead to the disease: X2699, X1320, X520, X2881 X2766, X1237, X2075, X521, X526 X526, X2766, X2106, X2075, X1533 X2699, X521, X2881, X1533, X1627 After a round of random mutations, we obtain 1187 mutated positions in total. This gives us an undirected weighted graph with 1187 nodes and 2838 edges, which produces an average degree of4.78. There is a single major component containing roughly 65% of its nodes. Expectedly, all causal pathways identified beforehand exist within this major connected component. Figure 4.1 shows the full graph, while Figure 4.2 shows its single major component. Using a resolution of 1, we obtained 25 modularity classes within the major connected component. The 12 selected positions are divided between two largest modules. \\[\\text{Figure} \\; 4.1 :\\; \\text{Full Network of Mutated Gene Base Positions}\\] \\[\\text{Figure} \\; 4.2 :\\; \\text {Modularity Class Decomposition within the Major Connected Component, with Nodes Sized According to Closeness Centrality}\\] 4.3 Centrality Measures Report Table 4.1 reports the top 12 nodes ranked by their degrees, eigenvector centrality, closeness centrality and betweeness centrality. The 12 effective disease-related positions selected are exactly the top 12 nodes with the greatest degrees and eigenvector centrality. This might be a result of the high degree of inter-connectivity among these positions. As a comparison, the \\(8^{th}\\), \\(10^{th}\\), and \\(12^{th}\\) nodes with the highest closeness centrality are random variations, while 8 of the top 12 nodes with the greatest betweenness centrality are random variations. Nodes colored blue below are random variables; nodes colored in red are nodes representing 12 SNP locations, where each is part of at least one combination. Rank Degree Eigenvector Centrality Closeness Centrality Betweeness Centrality 1 X2699 X2881 X2881 X2881 2 X2881 X2699 X2699 X2699 3 X521 X521 X1533 X1533 4 X2075 X1533 X520 X807 5 X2766 X2075 X1320 X2083 6 X526 X2766 X521 X2438 7 X1533 X526 X2075 X2251 8 X520 X520 X2766 X1301 9 X1320 X1320 X526 X1806 10 X1237 X1627 X39 X1739 11 X1627 X1237 X1627 X521 12 X2106 X2106 X1889 X571 \\[\\text{Tabble 4.1: Top 12 nodes with the highest degree, eigenvector centrality, closeness centrality and betweenness centrality}\\] 4.4 Preliminary Conclusions In this chapter, we found the exact 12 SNP locations that make up variant combinations. Network Science is powerful! Here comes the question: Why don’t we simply use degree centrality and eigenvector centrality to detect the SNP locations then? Why don’t we stop here? There are three reasons: Our goal is to not only find which mutations cause diseases, but also which combinations cause diseases. The centrality measures we have do not allow us to infer the structure of the subnetwork of 12 nodes. Our simulation uses co-occurrence counts to build edges, while in reality there could be more intrinsic ways to determine edges between SNPs. We choose the top 12 nodes for centrality measures because we know the underlying truth that there should be 12 SNP locations from our simulation. It is difficult to find a cutoff without knowing the exact number of SNP locations involved, provided that a distinguishable gap in centrality measures (in this case, between 12th and 13th) does not exist. "],["enhanced-influence-model.html", "Chapter 5 Enhanced Influence Model 5.1 Graph Diffusion Kernel 5.2 Enhanced Influence Model 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) 5.4 Alternative Situation 5.5 Code", " Chapter 5 Enhanced Influence Model After constructing a network using our simulated data, we moved on to use the Enhanced Influence Model to identify significant subnetworks within the graph that shed light on genetic causal pathways. We will first introduce the graph diffusion kernel as the first step to measure the extent of mutual interaction between genes in our network. 5.1 Graph Diffusion Kernel Here we imagine that the importance of nodes flows along edges. Initially, query nodes are selected to serve as sources where fluid is pumped in at a constant rate which then diffuses through the network. In addition, we assume that fluid leaks out of each node at a constant rate \\(\\gamma\\). Intuitively, large \\(\\gamma\\) means faster rate of loss and therefore shorter diffusive paths. Essentially, the paths reflects diffusion of random walkers from a source. At equilibrium, there is no net flow in the entire network. The more interaction a node has with the query nodes, the more fluid it will contain at the equilibrium (Qi et al., 2008). Following the procedure in previous literature (Vandin, Upfal, and Raphael, 2011), we set \\(\\gamma = 5\\), which is approximately the average degree of a node in our network. Mathematically,let \\(u(t)\\) denotes the unit step function where \\[u(t) = \\begin{cases}0 \\;\\text{ if }\\;t&lt;0\\\\1 \\;\\text{ if }\\;t&gt;0 \\end{cases},\\] and \\(b_i = 1\\) if i is the source node of interest while \\(b_i = 0\\) otherwise. The amount of fluid contained by node \\(i\\) at time t is \\(x_i(t)\\) is governed by the flow in and out of it, \\[\\frac{d}{dt}x_i(t) = \\sum_j A_{ij}x_j(t)-\\sum_jA_{ji}x_i(t)-\\gamma x_i(t)\\] As \\(t\\to \\infty\\), the fluid distribution approaches to its equilibrium distribution at which the influence of node \\(i\\) to other nodes is measured by \\[L_\\gamma^{-1}\\vec{b_i}\\] where \\(\\vec{b_i}\\) is the standard basis with 1 at its \\(i^{th}\\) entry. Here, \\(L_\\gamma = S-A+\\gamma I\\) is the shifted graph Laplacian by \\(\\gamma\\) where \\(S\\) is the diagonal matrix whose diagonal entries are the corresponding degrees. In practice, we normalize A symmetrically by \\(S^{-\\frac{1}{2}}AS^{-\\frac{1}{2}}\\) such that the edge weights between two nodes are normalized by the degrees and replace \\(S\\) correspondingly to obtain the Laplacian (Qi et al. 2008). Here, the \\(ij\\) entry of \\(L_\\gamma^{-1}\\) gives the influence of \\(j\\) on \\(i\\), which may or may not equal to the \\(ji\\) entry of \\(L_\\gamma^{-1}\\). To better interpret the result, we define the mutual influence between i and j to be \\(\\tilde{i}(i,j) = \\min(L_\\gamma^{-1}[i,j],L_\\gamma^{-1}[j,i])\\). (Vandin, Upfal, and Raphael, 2011) 5.2 Enhanced Influence Model Enhanced Influence Model is an efficient algorithm to identify a significantly mutated subnetwork with respect to gene interactions by incorporating considerations of both the topology of the network and significance of individual genes with respect to the disease (Vandin, Upfal, and Raphael, 2011). Below are the key procedures involved in the Enhanced Influence Model: Recall from Chapter 4, marginal regression gives a p-value, \\(p_i\\) for each gene \\(i\\). We then assign a score \\(\\sigma_i\\) to a gene \\(i\\) where \\(\\sigma_i = -2\\log(p_i)\\). For each pair of genes (\\(i\\),\\(j\\)), their mutual interaction is measured by \\(w(i,j) = \\max(\\sigma_i,\\sigma_j)*\\tilde{i}(i,j)\\) (Vandin et al., 2011). Next, we remove all edges with weights smaller than a threshold \\(\\delta\\) to obtain a subgraph. In Section 5.3, we shall exhibit a method to determine this cold-edge threshold \\(\\delta\\). The connected components remained are candidates for genetic pathways. The code below shows how we construct the enhanced influence model from scratch. # normalize A A_normalized &lt;- matrix(0,nrow(A),nrow(A)) for(i in 1:(nrow(A)-1)){ for(j in i:nrow(A)){ if(deg[i]!=0 &amp;&amp; deg[j]!=0){ A_normalized[i,j] &lt;- A[i,j]/sqrt(deg[i]*deg[j]) } } } A_normalized &lt;- forceSymmetric(A_normalized,&quot;U&quot;) A_normalized &lt;- as.matrix(A_normalized) # normalize the corresponding degree matrix S S_normalized &lt;- diag(rowSums(A_normalized)) gamma &lt;- 5 L_gamma &lt;- S_normalized+diag(gamma,nrow(A))-A_normalized inv_L_gamma &lt;- solve(L_gamma) # compute symmetric importance score using Enhanced Influence Model W &lt;- matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W[i,j] &lt;- min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(mutations_score[i],mutations_score[j]) } } # helper function to remove cold_edge removeColdEdge &lt;- function(mat,W,delta){ hotnet &lt;- mat for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ if(W[i,j]&lt;delta){ hotnet[i,j] = 0 } } } return(hotnet) } Hotnet &lt;- removeColdEdge(A_normalized,W,0.04) Hotnet &lt;- as.matrix(forceSymmetric(Hotnet,&quot;U&quot;)) colnames(Hotnet) &lt;- position rownames(Hotnet) &lt;- position HotEdges &lt;- melt(Hotnet) %&gt;% rename(Source = Var1, Target = Var2, Weight = value) %&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0) %&gt;% select(-Weight) edges.copy &lt;- edges edges.copy &lt;- edges.copy %&gt;% select(Source,Target) colnames(edges.copy) &lt;- c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) # get a list of connected components clu &lt;- components(g) res &lt;- groups(clu) getNumComp &lt;- function(edges,nodes,s){ edges.copy = edges edges.copy = edges.copy%&gt;%select(Source,Target) colnames(edges.copy) = c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) clu &lt;- components(g) res &lt;- groups(clu) count &lt;- 0 for(i in 1:length(res)){ if(length(res[[i]]) &gt;= s){ count = count+1 } } return(count) } 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) In this section, we illustrate a way to determine the value for \\(\\delta\\). We start with simulating 50 datasets under \\(H_0^P\\) by permuting observed disease status. (Vandin et. al, 2012) Then, for a small value of \\(s\\), where often \\(s \\in \\{3,4,5\\}\\), we choose the first \\(\\delta\\) that gives the largest number of subnetworks of size at least \\(s\\). Given the size of our network, we use \\(s = 3\\). Table 5.1 report the number of connected components of size at least 3 as a function of \\(\\delta\\). delta value 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 Num.Components, Size&gt;3 100.30 118.10 50.20 10.50 2.40 2.40 2.40 0.00 0.00 \\[\\text{Table 5.1: Number of Components of Size at Least 3 as a Function of} \\;\\delta\\] According to Vandin (2012), an empirical choice is using a first \\(\\delta\\) that gives the maximum number of connected components of size at least 3, which gives \\(\\delta = 0.02\\) in our case. Since increasing \\(\\delta\\) gives us more conservative criteria, we also consider the following values: \\(1.5\\delta = 0.03, 2\\delta = 0.04, 3\\delta = 0.06, 4\\delta = 0.08\\). In fact, if \\(\\delta_1 &gt;\\delta_2\\), then the connected components of size at least 3 obtained using \\(\\delta_2\\) will be subnetworks of those obtained using \\(\\delta_1\\). We applied the above \\(\\delta\\) values to filter the edges and obtained 5 graphs using the graph presented in Chapter 4. Intuitively, as we raise the value for \\(\\delta\\), there will be more isolated nodes and the size of major component will decrease as it gets decomposed into smaller parts. We expect the the true causal pathways will be among the connected components after applying the Enhanced Influence Model and filtering the edges. Figures 5.1 (a) - (e) shows their corresponding major components, which contained the 4 genetic causal pathways listed in Chapter 4. \\[\\text{Figure 5.1(a): Major component of the network of mutated genes when delta = 0.02}\\] \\[\\text{Nodes Sized by Closeness Centrality}\\] \\[\\text{Figure 5.1(b): Major component of the network of mutated genes when delta = 0.03}\\] \\[\\text{Figure 5.1(c): Major component of the network of mutated genes when delta = 0.04}\\] \\[\\text{Figure 5.1(d): Major component of the network of mutated genes when delta = 0.06}\\] \\[\\text{Figure 5.1(e): Major component of the network of mutated genes when delta = 0.0}\\] We found that at \\(\\delta = 0.04\\) and \\(\\delta= 0.06\\), the major component both contains precisely the 12 SNP locations that were part of at least one pathway interaction combination. To determine which one of the two is better, we go back to the four original pathways and evaluate their quality. It seems that the major component more accurately describes the truth when \\(\\delta = 0.04\\), as presented below. \\[\\text{Figure 5.2: Modularity Class Breakdown within the Major Component when delta = 0.04}\\] 5.4 Alternative Situation In the previous section, we find that our method is confused about which modularity class a certain node belongs to. We hypothesize that this may be due to that the node makes up more than one combination of pathway interactions. We wonder if the problem will arise when each mutation only contributes to one pathway combination (denoted as Scenario B). If the problem universally happens, we need to analyze its cause. We repeated the process, with a twist in the construction of the original dataset. We simulated a dataset where no two pathways share a SNP location. Random simulation gives the following 4 causal genetic pathways: X2608, X182, X1443, X624, X2422 X2454, X1099, X350, X2548, X883 X31, X2725, X608, X471 X815, X2108, X2494, X2812, X1245 Figure 5.3 shows the full network of SNP locations where at least one mutation occurs where the purple part is the largest connected component. \\[\\text{Figure 5.3: Figure Full Network of Mutated Genes under Scenario B}\\] delta value 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 Num.Components, Size&gt;3 100.30 118.10 50.20 10.50 2.40 2.40 2.40 0.00 0.00 \\[\\text{Table 5.2: Number of Components of Size at Least 3 as a Function of} \\;\\delta \\;\\text{under Scenario B}\\] The empirical choice \\(\\delta&#39; = 0.04\\) gives the first mamimum average number of connected components of size at least 3. Experimenting with \\(\\delta = 1.5\\delta&#39;\\) and \\(\\delta = 2\\delta&#39;\\) shows that \\(\\delta = 2\\delta&#39;=0.08\\) gives a perfect fit. Figure 5.4 shows the filtered network obtained from Figure 5.3 using \\(\\delta = 0.08\\). Observe that there is no single major connected components. However, all four pathways exist as independent connected components that are colored in Figure 5.4. Figure 5.5 shows the the filtered graph for the four components. All 4 pathwaysa re identified, which supplies proof for the validity of our method. \\[\\text{Figure 5.4: Resulted Network using}\\; \\delta=0.08 \\;\\text{under Scenario B}\\] \\[\\text{Figure 5.5: All 4 Pathways Identified under Scenario B}\\] 5.5 Code Below is the code that supports our work in this chapter. disease_status_mat &lt;- matrix(NA,50,500) for(i in 1:50){ disease_status_mat[i,] &lt;- permute(disease_status_vector) } pVal.lst &lt;- list() for(k in 1:50){ res &lt;- c() for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_mat[k,]&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) res &lt;- c(res,summary(model)$coefficient[,4][2]) pVal.lst[[k]] = res } } score.lst = list() for(k in 1:50){ score.lst[[k]] = -2*log(pVal.lst[[k]]) } W.lst = list() for(k in 1:50){ W.lst[[k]] = matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W.lst[[k]][i,j] = min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(score.lst[[k]][i],score.lst[[k]][j]) } } } aveNumComp_s &lt;- function(delta, s=3){ # list of adjacency matrices for HotNet for 50 datasets under the null hypothesis # under the given threshold delta Hotnet.lst = list() for(k in 1:10){ Hotnet.lst[[k]] = removeColdEdge(A_normalized,W.lst[[k]],delta) Hotnet.lst[[k]] = as.matrix(forceSymmetric(Hotnet.lst[[k]],&quot;U&quot;)) } HotEdges.lst = list() for(k in 1:10){ colnames(Hotnet.lst[[k]]) = position rownames(Hotnet.lst[[k]]) = position HotEdges.lst[[k]]= melt(Hotnet.lst[[k]]) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0)%&gt;%select(-Weight) } numComp_s = rep(0,10) for(k in 1:10){ numComp_s[k] = getNumComp(HotEdges.lst[[k]],nodes,s) } return(mean(numComp_s)) } x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=3) x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=2) "],["discussion-and-future-work.html", "Chapter 6 Discussion and Future Work 6.1 What did we achieve? 6.2 Limitations 6.3 Future Work", " Chapter 6 Discussion and Future Work 6.1 What did we achieve? The most exciting part of this project to us is using network science to solve real-life problems. Genetics is such an complex topic and affects every part of who we are. Given how chemistry works in our body, it is hard to imagine that we could accurately quantify how genes interact with each other. But we are excited to learn that with some basic assumptions, one could have some predicting power with mathematical tools, even though we have to leave out many details in our modeling process. The takeaway is that we are able to model how pathway interactions cause diseases and use network science tools to detect such pathways. Our assumption states that diseases/traits can be caused by a combination of mutations at SNP locations, and one mutation may be involved in multiple combinations. This poses an inherent challenge for network analysis: it is hard to classify which modularity class that such mutations should belong to. However, we present that our method perfectly classifies different pathway interactions if one mutation could only exist in one combination. 6.2 Limitations A major limitation, as discussed above, is the adherence to biological facts. It is not feasible to exactly replicate the complex biochemical processes along the DNA sequence, and thus our assumptions bear the risk of not representing the reality. During our analysis, we first pre-determined which combinations of variants along the genome could lead to the disease/trait. However, we do not know the underlying true combinations of pathway interactions in real life. When implementing our algorithm in a more realistic setting, we may have difficulty interpreting the validity of the result. For example, in Chapter 4, we see that our method perfectly detects the combination “X2699, X1320, X520, X2881”, and yields slight discrepancies in other combinations. Thus, it is important to test the algorithm in different settings and better understand how the results may be impacted. In addition, many inputs of our method are chosen relatively arbitrarily based on existing literature. We attempted many different values for variables including total SNP locations and the number of combinations. It is, however, important to note that we could not test all potential values for all variables. We would like to understand changes in our algorithm’s accuracy if we have a larger number of SNP locations or more possible combinations etc. 6.3 Future Work Given the time constraint, many interesting problems and extensions remain to be explored and discussed. One extension that we mentioned earlier is how we can incorporate two disease/traits and their corresponding pathways and check if our method accurately detects both pathways under a different setting of noises. In addition, there may be other tools designed for our setting, which may incorporate work from network science, statistical genetics or computational biology. "],["references.html", "Chapter 7 References", " Chapter 7 References Leiserson, M. D., Eldridge, J. V., Ramachandran, S., &amp; Raphael, B. J. (2013). Network analysis of GWAS data. Current opinion in genetics &amp; development, 23(6), 602-610. https://doi.org/10.1016/j.gde.2013.09.003 Vandin, F., Clay, P., Upfal, E., &amp; Raphael, B. J. (2012). Discovery of mutated subnetworks associated with clinical data in cancer. Pacific Symposium on Biocomputing. Pacific Symposium on Biocomputing, 55-66. Vandin, F., Upfal, E., &amp; Raphael, B. J. (2011). Algorithms for detecting significantly mutated pathways in cancer. Journal of computational biology : a journal of computational molecular cell biology, 18(3), 507-522. https://doi.org/10.1089/cmb.2010.0265 Qi, Y., Suhail, Y., Lin, Y. Y., Boeke, J. D., &amp; Bader, J. S. (2008). Finding friends and enemies in an enemies-only network: a graph diffusion kernel for predicting novel genetic interactions and co-complex membership from yeast genetic interactions. Genome research, 18(12), 1991-2004. https://doi.org/10.1101/gr.077693.108 What Are Single Nucleotide Polymorphisms (SNPs)? (n.d.). Retrieved from https://medlineplus.gov/genetics/understanding/genomicresearch/snp/ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= fc9bc3389f10c78caadaa9d56096928a52c78f21 "]]
