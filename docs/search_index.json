[["index.html", "MATH 479 Network Science Project Preface", " MATH 479 Network Science Project Zhaoheng Li and Zuofu Huang, Fall 2020 Macalester College Preface Hello! Welcome to our final project of Network Science! This bookdown is a work in progress, and please check back early and often (as much as people do to their Github code). Feel free to contact us if you have any questions! Now that we are in the realm of networks, we feel compelled to motivate our project with an xkcd comic related to networks. Credit to xkcd: https://xkcd.com/350/ "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction We are motivated by existing genetic association studies that find the correlation between certain diseases/traits and genetic variants (SNP mutations). We wonder if network analysis can be utilized in the process of genome-wide association studies. Genome wide association studies (GWAS) is a method for identifying the associations between certain genetic regions called loci and one’s trait. Usually among the traits, we are interested in the disease status. Later, we came across the paper named Network Analysis of GWAS data (Leiserson et. al, 2013), where we first saw the connection made between genetics and network science. This motivates our attempt of finding genetic pathway interactions for a certain disease/trait. Intuitively, we would like to think of the simplified scenario: a certain disease can be caused by several genetic pathways. Suppose we have \\(n\\) SNP locations previously identified as related to the disease, and \\(k\\) subsets among the SNP locations that in combination cause the disease (\\(k &lt; n\\)). Our goal is to simulate data that aligns with the proposed setting, and use network science tools to identify these pathway interactions (pretending that we did not know the underlying true subsets). This process aims at testing the validity of the network science tool we propose. Looking forward, we would like to test how the tool behaves when the dataset we simulate contains genetic information for two diseases: we wonder if the algorithm is capable of picking up pathway interaction patterns for both diseases. "],["initial-steps.html", "Chapter 2 Initial Steps 2.1 Genetics Background 2.2 Simulate original data 2.3 Sample mutations for patients at SNP locations 2.4 Sample mutations for non-patients at SNP locations 2.5 Variants at non-SNP locations 2.6 Screening 2.7 Marginal Regression 2.8 Discussion", " Chapter 2 Initial Steps Our initial thought was that Genome-Wide Association Studies data is readily available for public access and that we should be able to retrieve the dataset easily. However, it came unexpected that a research proposal from faculty was needed to obtain GWAS data for research purposes. Therefore, we decide to simulate our own GWAS data for the purpose of this research. 2.1 Genetics Background The human genome contains roughly 234,000 exons, 80% of which contain fewer than 200 base pairs in length. However, mutations in these exons contain a majority of mutations that are related to diseases. Our setting is structured in this context. Suppose we have a disease. It is reasonable to assume that we know where the mutations related to this disease approximately are along the genome. We guess that 1000 loci (specific position where a gene is located) could harbor the disease-related mutations. In addition, we assume that each locus on average contains 200 base pairs (a pair of complementary bases in a double-stranded DNA: A-T, G-C), which corresponds to locus_length &lt;- 200 in the code. loci &lt;- 1000 locus_length &lt;- 200 2.2 Simulate original data We start by creating the dataset. Everyone row is set to the reference level first (i.e. there is no variant). Suppose initially we have 500 individuals, and we categorize 100 as people who have the disease. n &lt;- 500 n_disease &lt;- 100 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = loci*locus_length, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = loci * locus_length,byrow = TRUE)) SNP_location &lt;- sample(1:(loci*locus_length), size = 50, replace = FALSE) reference_level_SNP_location &lt;- reference[SNP_location] 2.3 Sample mutations for patients at SNP locations We then sample mutations at SNP locations who were categorized at patients. disease_people_row_number &lt;- sample(1:500, 100, replace = FALSE) combo_number &lt;- 15 SNP_number &lt;- sample(1:6, combo_number, replace = TRUE) disease_combo &lt;- list() for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) #helper functions for decomposition. helper2 &lt;- function(char){ other_set &lt;- setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;G&quot;,&quot;C&quot;),char) return(sample(other_set,1)) } helper3 &lt;- function(char, p = 0.15){ random &lt;- runif(1) if (random &lt;= (1-3*p)){ return(char) } else if (random &lt;= 1-2*p){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[1]) } else if (random &lt;= (1-p)){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[2]) } else { return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[3]) } } # For patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper2(reference_level_SNP_location[index[j]]) } # non-disease-related SNP mutations non_forced_index &lt;- setdiff(1:50, index) for (k in 1:length(non_forced_index)){ reference_level_SNP_location_copy[non_forced_index[k]] &lt;- helper3(reference_level_SNP_location[non_forced_index[k]],0.15) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy } 2.4 Sample mutations for non-patients at SNP locations We then hypothesize that given a common condition, non-patients are also more likely to have mutations at the SNP locations than at most other locations (e.g. those locations that make human human). # For those who are not set to have disease first (400) # Loop over 50 genes, each one has some possibility to mutate. (More likely than the other nucleotides on the genome) non_disease_row_number &lt;- setdiff(1:500,disease_people_row_number) for (i in non_disease_row_number){ for (j in SNP_location) data[i,j] &lt;- helper3(data[i,j],0.05) } 2.5 Variants at non-SNP locations The next step is simulating random noise at non-SNP locations to better mimic properties of gene mutations in real life. potential_SNP_places &lt;- SNP_location potential_random_change_sites &lt;- setdiff(1:(loci*locus_length),SNP_location) for (i in 1:n){ random_locus &lt;- sample(potential_random_change_sites, size = (loci*locus_length/1000), replace = FALSE) # definitely change for(j in random_locus){ data[i,j] &lt;- helper2(data[i,j]) potential_SNP_places &lt;- c(potential_SNP_places, random_locus) } } potential_SNP_places &lt;- unique(potential_SNP_places) 2.6 Screening With the mutations that non-patients had at SNP locations, some of the 400 people may fall into the “disease” status. We then performed a round of screening for 400 people who were initially categorized without the disease. Surprisingly, we found that a large number of people fall into the “disease” status. We were surprised for two reasons: The probability of mutations at each location is low. Even if many mutations happen for someone, a right “combination of pathways” is needed to achieve the “disease” status, which happens more often than estimated. # Do a round of screening for 400 people who did not initially have the disease NewPatient &lt;- c() for (i in non_disease_row_number){ MutatedSNP &lt;- c() for(j in SNP_location){ if(isMutated(i,j)){ MutatedSNP &lt;- c(MutatedSNP,j) } } for(k in 1:15){ if(all(disease_combo[[k]] %in% MutatedSNP)){ causalPathway &lt;- c() for(position in disease_combo[[k]]){ causalPathway = c(causalPathway,helper2(reference[position])) } if(all(data[i,position] == causalPathway)){ NewPatient &lt;- c(NewPatient,i) break } } } } disease_row_final &lt;- c(disease_people_row_number, NewPatient) disease_status_vector &lt;- rep(FALSE, 500) for (i in 1:500){ if (i %in% disease_row_final){ disease_status_vector[i] &lt;- TRUE } } 2.7 Marginal Regression Once we have simulated potential variants for everyone at every location, we find all places that at least one person has a variation at, select the places and fit a marginal regression at each location against the disease status. for (i in potential_SNP_places){ reference_level_here &lt;- reference[i] for (j in 1:n){ if (data[j,i] == reference_level_here){ data[j,i] &lt;- TRUE } else { data[j,i] &lt;- FALSE } } } subdata &lt;- data[,potential_SNP_places] isMutated &lt;- function(person,position){ if(data[person,position] == reference[position] ){ return(FALSE) } else{ return(TRUE) } } for (i in potential_SNP_places){ summary(lm(disease_status_vector ~ data[,i])) } 2.8 Discussion Problems with this approach, as we realized later, were that: We assumed genetic variants were the only reason people caused the disease, which was almost never the case. People who were initially categorized as non-patients and later changed their status are more than we expected. This casts doubt on the necessity of pre-determining the number of patients (100 in this case). Our approach was not fully supported by pre-existing literature. We pasted pieces of several literature into this approach. The probability of mutations at each location was also not documented. When we are simulating random variants, we set the number of changes to be size = (loci*locus_length/1000) as we believed the average probability of SNP is 1/1000. However, this is faulty because the size was fixed at the expected value of the number of mutation sites, without allowing any difference across individuals. Let \\(\\text{X = number of variants}\\) and \\(\\text{n = number of locations}\\). \\(X\\) follows the distribution: \\(X \\sim Bin(n,p)\\). However, \\(X\\) can vary as we draw from the Binomial distribution. With the reasons above, we keep digging into the literature and tested potential alternatives. "],["progress-and-revision.html", "Chapter 3 Progress and Revision 3.1 Rationale 3.2 Updated Code", " Chapter 3 Progress and Revision 3.1 Rationale When we found out that only SNP locations can be categorized as significant and other loci are exclusively “non-significant”, we realized that we are getting too far into simulation. Although it seemed that every step we take is justified, the simulated data seem unrealistic and overfitting for our scenario. As we were conduting a more extensive literature review process in the hope of shedding light on our next simulation steps, we came across the paper Discovery of Mutated Subnetworks Associated with Clinical Data in Cancer (Vandin et. al, 2012). Section 3.1 of the paper contains a description of how the data is simulated in a slightly different setting. There are a few notable changes that we implemented in the Progress and Revision section. We argue that a common disease can be caused by both genetic variants and external environmental factors, as opposed to the genetic variations alone in our previous simulations. Therefore, we can pre-determine the number of people whose diseases are caused by genetic factors (as the paper suggested, 20% of people who carry the disease). The value of \\(p\\) is determined by the biological background that on average the probability of having a mutation at each location is \\(1/1000\\), as described in “What Are Single Nucleotide Polymorphisms (SNPs)?” (n.d.). For people whose diseases are caused by genetic factors: the probability of mutations at every other location (including SNP locations that were not in their combination) has a probability of \\(p = 1/1000\\). For people whose diseases are caused by non-genetic factors: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For people who do not have the disease: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For the purpose of the simulation, we combine the group of people whose disease are caused by non-genetic factors and the group of people who do not carry the disease. Suppose we have a total of 500 people, half of which do not carry the disease. Then the total number of people whose disease are caused by genetic factors is 10% of the total population, as seen in n_disease &lt;- 0.1n in the Update Code section below. We determine that there are 4 combinations of genetic pathways that cause the disease (which is much more realistic than 15 pathways). Each of the pathway contains a random group of 4-5 variants chosen from 15 SNP locations. The variant could be present in more than one pathway or none of the pathways. We replace the multiplication of loci and locus_length with a total positions of 3000. We argue that reducing the number of loci at first does not change our inference process. As we test the validity of the approach, we then have the freedom of increasing the dimension (column) of the dataset or incorporating another disease/trait and the corresponding genetic pathways in our analysis. 3.2 Updated Code n &lt;- 500 n_disease &lt;- n*0.1 total_position &lt;- 3000 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = total_position, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = total_position,byrow=TRUE)) disease_people_row_number &lt;-seq(1,n_disease) non_disease &lt;- seq((n_disease+1),n) combo_number &lt;- 4 disease_combo &lt;- list() SNP_number &lt;- sample(4:5, combo_number, replace = TRUE) SNP_location &lt;- sample(1:total_position, 15, replace = FALSE) for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } reference_level_SNP_location &lt;- reference[SNP_location] disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) helper &lt;- function(char){ return(sample(setdiff(c(&quot;A&quot;,&quot;C&quot;,&quot;T&quot;,&quot;G&quot;),char),1)) } # function to mutate positions not in the identified pathways mutater &lt;- function(vec,non_position){ mutated &lt;- c() for (i in 1:length(vec)){ if (! i %in% non_position){ rand &lt;- runif(1) if (rand &lt;= 10^{-3}){ vec[i] &lt;- helper(vec[i]) mutated &lt;- c(mutated, i) } } } return(list(vec,mutated)) } # all mutated positions mutated_position &lt;- SNP_location # keep track of mutated positions for each subject # to record co-occurrence frequency of mutations # For causal-pathway-related patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper(reference_level_SNP_location[index[j]]) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy # random change mutated_result &lt;- mutater(data[i,],thiscombo) data[i,] &lt;- mutated_result[[1]] # update the list of all positions that mutated mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } # for everyone else for (k in (n_disease+1):n){ # update mutated positions mutated_result &lt;- mutater(data[k,], SNP_location) data[k,] &lt;- mutated_result[[1]] mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } mutated_position &lt;- unique(mutated_position) # Delete the locations among the 15 pre-identified locations that are not selected to be part of a causal pathway del &lt;- c() for(p in mutated_position){ count &lt;- 0 if(all(data[,p]==reference[p])){ del &lt;- c(del,p) } } mutated_position &lt;- setdiff(mutated_position,del) # Create a subset of the data for all positions with at least one mutation for(position in mutated_position){ # return true if a mutation happens at the position data[,position] &lt;- !(data[,position]==reference[position]) } sub_data &lt;- data[,mutated_position] position &lt;- colnames(sub_data) Create the adjacency matrix A that contains all positions where there is at least one mutation across all subjects. A = matrix(0,length(mutated_position),length(mutated_position)) rownames(A) = colnames(sub_data) colnames(A) = colnames(sub_data) for(i in 1:nrow(sub_data)){ count = sum(sub_data[i,]==TRUE) if(count&gt;=2){ loc = which(as.logical(as.vector(sub_data[i,])),TRUE) pairs_mat = combn(loc,2) for(j in 1:ncol(pairs_mat)){ r = pairs_mat[1,j] c = pairs_mat[2,j] A[r,c] = A[r,c]+1 } } } A &lt;- as.matrix(forceSymmetric(A,&quot;U&quot;)) Calculate the degree of the adjacency matrix. We can understand more of the matrix by calculating the average degree. deg &lt;- rowSums(A) deg ## X1643 X2897 X2915 X2379 X2218 X1262 X2622 X98 X1481 X2031 X1981 X2763 X2806 ## 94 349 194 61 126 223 159 129 94 255 7 16 10 ## X179 X2966 X186 X749 X923 X77 X1302 X1386 X2799 X2968 X1567 X1764 X2195 ## 5 5 6 6 6 9 9 9 9 19 15 11 14 ## X2461 X2552 X392 X635 X2137 X2603 X1246 X1636 X1726 X2220 X1989 X2159 X2431 ## 9 17 8 16 8 8 12 8 18 8 11 12 9 ## X759 X1022 X1841 X2334 X2406 X691 X802 X1284 X2305 X412 X526 X2463 X2592 ## 9 9 15 9 9 8 8 8 8 7 6 8 6 ## X1504 X1944 X2455 X2922 X409 X1408 X1908 X385 X1354 X1622 X2779 X361 X654 ## 8 8 8 8 7 20 7 8 8 17 14 10 10 ## X1378 X2074 X2237 X2962 X952 X2605 X8 X501 X1499 X2267 X2676 X604 X743 ## 10 10 10 10 5 5 12 12 16 10 14 13 10 ## X1429 X2857 X896 X953 X1762 X2515 X2677 X558 X991 X2434 X1198 X1648 X2905 ## 10 16 7 7 7 15 8 5 6 10 7 7 7 ## X1330 X2111 X137 X222 X2115 X2924 X2964 X1594 X2405 X2894 X727 X1424 X1581 ## 6 6 14 9 9 9 9 7 7 7 11 11 11 ## X2183 X2277 X2824 X2923 X708 X1097 X1067 X1691 X2558 X1722 X164 X485 X2700 ## 11 11 11 14 16 6 12 7 7 7 10 7 10 ## X1121 X1917 X2371 X1052 X2394 X2511 X357 X1986 X1991 X2866 X2018 X2501 X2687 ## 7 7 7 7 10 11 18 13 8 10 5 6 6 ## X2848 X94 X359 X1202 X2579 X1159 X1512 X656 X1574 X1693 X2812 X793 X1934 ## 6 8 8 8 8 6 6 8 8 8 9 8 8 ## X1935 X2222 X271 X986 X1739 X1833 X2016 X1127 X2029 X2453 X160 X321 X587 ## 11 8 9 16 13 9 9 5 8 8 11 11 11 ## X974 X1309 X2341 X2577 X1122 X2411 X2836 X1081 X1197 X1820 X2194 X517 X2219 ## 11 11 15 11 2 2 8 3 3 5 0 0 1 ## X2366 X80 X457 X2110 X2878 X1012 X2906 X1435 X1800 X1179 X1705 X2171 X2977 ## 5 3 11 3 3 0 0 1 1 6 4 3 3 ## X871 X1563 X2098 X2102 X2986 X609 X1069 X2097 X527 X1558 X767 X1329 X2576 ## 2 7 3 3 3 5 2 2 1 1 2 2 2 ## X1469 X1593 X2512 X2540 X2994 X2076 X2578 X351 X1014 X2280 X2435 X31 X319 ## 5 4 4 4 8 1 2 7 9 3 3 5 5 ## X1247 X1417 X1514 X2271 X648 X1570 X897 X1165 X2084 X2637 X1600 X2572 X2872 ## 7 5 5 8 3 0 3 9 11 3 2 2 4 ## X5 X705 X2094 X2300 X2438 X15 X2533 X2769 X894 X1887 X2428 X965 X1219 ## 9 6 5 4 8 2 2 2 2 2 2 3 3 ## X1310 X273 X1740 X1458 X2145 X1928 X2363 X272 X1778 X2413 X1327 X1518 X1391 ## 3 1 1 1 5 1 1 2 6 4 4 2 3 ## X1678 X1886 X2099 X2546 X2581 X78 X260 X828 X2842 X972 X1254 X2454 X1146 ## 3 4 5 1 1 1 2 2 2 0 1 5 5 ## X1996 X2182 X368 X1615 X2104 X524 X2051 X2621 X2566 X311 X955 X2535 X374 ## 2 3 2 3 2 2 2 2 1 8 2 2 9 ## X659 X863 X1462 X1716 X2143 X811 X1506 X1845 X2536 X761 X865 X617 X1534 ## 11 7 5 5 5 3 3 5 4 1 1 5 7 ## X2148 X2587 X2755 X2791 X199 X946 X1059 X1851 X350 X1308 X2132 X2850 X1298 ## 5 5 11 8 5 4 10 6 3 3 5 5 1 ## X2017 X2217 X66 X217 X141 X877 X1582 X815 X1416 X1352 X2117 X318 X1748 ## 1 1 2 2 0 4 2 3 2 2 7 18 2 ## X1968 X2560 X2395 X2703 X622 X644 X1675 X122 X343 X331 X1000 X1471 X2078 ## 2 0 2 2 10 3 3 3 2 4 4 5 4 ## X252 X2370 X25 X2255 X2772 X101 X1372 X1257 X2015 X2993 X499 X1543 X2400 ## 2 5 8 2 4 2 8 2 2 2 2 2 3 ## X67 X1738 X1788 X2392 X1072 X1214 X1382 X1699 X1875 X1910 X1997 X2737 X1216 ## 7 3 3 3 5 5 6 5 5 2 3 2 2 ## X1767 X2352 X434 X805 X515 X928 X1374 X2502 X548 X943 X316 X1703 X1109 ## 17 2 2 2 3 4 3 3 1 1 1 1 4 ## X1508 X1533 X1038 X1301 X1402 X1603 X2141 X2524 X23 X966 X1085 X1734 X478 ## 1 0 5 9 5 8 5 5 2 2 2 0 7 ## X837 X2350 X2433 X2489 X401 X417 X570 X2191 X402 X852 X2550 X539 X975 ## 8 5 5 5 4 3 3 5 4 4 4 4 9 ## X1625 X1735 X1959 X1221 X1275 X1562 X1681 X2845 X371 X2937 X227 X1058 X1606 ## 4 4 4 4 4 10 7 4 1 0 2 2 0 ## X274 X2519 X113 X796 X2003 X2283 X2717 X2971 X2880 X39 X642 X1110 X1969 ## 1 1 6 6 6 6 9 6 4 4 4 4 4 ## X2446 X801 X1345 X151 X363 X1487 X1890 X1049 X1184 X1476 X2636 X436 X1013 ## 4 1 1 4 6 10 4 2 4 1 1 11 4 ## X1697 X2626 X2668 X255 X554 X754 X1188 X1544 X2214 X2741 X1339 X1490 X500 ## 4 4 10 2 3 2 3 11 4 3 2 2 1 ## X1488 X2792 X1369 X1746 X1771 X1990 X2932 X1406 X1773 X1181 X585 X1057 X1498 ## 5 2 0 6 3 3 5 1 1 1 5 5 5 ## X1857 X1947 X2732 X211 X783 X1076 X1169 X624 X1305 X2648 X2881 X266 X235 ## 11 7 9 4 6 4 6 2 2 3 2 0 4 ## X997 X2149 X1384 X2179 X1608 X551 X449 X795 X1343 X2945 X850 X2516 X2935 ## 4 4 4 1 0 0 3 3 3 3 3 3 3 ## X305 X1088 X1383 X1434 X1467 X1689 X2620 X2719 X809 X844 X2466 X694 X1200 ## 13 7 7 7 7 7 7 7 2 4 5 3 3 ## X1753 X2314 X81 X1126 X1346 X1548 X1711 X1925 X914 X2238 X2570 X1805 X2241 ## 4 3 9 6 4 4 4 4 4 13 4 2 2 ## X2936 X1009 X1452 X1905 X591 X1665 X2886 X664 X1789 X405 X445 X956 X1263 ## 2 2 2 5 2 2 7 7 7 0 2 2 6 ## X1964 X2302 X1400 X1623 X2858 X1547 X2597 X394 X1113 X1418 X1682 X2655 X2776 ## 2 1 2 2 2 1 1 6 10 6 6 6 6 ## X561 X658 X1001 X1782 X1030 X1137 X2286 X354 X208 X230 X381 X491 X294 ## 0 5 3 3 4 4 4 0 6 4 4 10 1 ## X1810 X1809 X1242 X2416 X2723 X2973 X326 X1120 X2072 X2121 X1864 X2239 X2849 ## 1 3 0 2 2 2 3 3 3 3 3 3 3 ## X171 X1876 X2354 X2682 X1866 X544 X1680 X1690 X2678 X107 X505 X549 X1669 ## 4 4 4 4 0 3 4 3 3 4 6 4 4 ## X641 X1977 X2625 X2882 X1463 X1916 X595 X2415 X2224 X2275 X2658 X836 X1834 ## 3 3 3 3 1 1 3 3 1 1 4 2 2 ## X2843 X1844 X58 X1353 X2483 X303 X464 X778 X2249 X2306 X220 X2718 X2902 ## 2 1 1 1 2 7 9 5 2 2 2 2 2 ## X649 X2206 X450 X497 X546 X993 X1245 X2033 X2613 X625 X638 X2907 X2500 ## 4 2 11 7 7 7 7 10 7 3 3 3 1 ## X110 X1232 X335 X680 X1720 X2200 X2296 X1068 X2840 X2263 X2698 X1869 X2025 ## 2 2 5 5 9 5 8 2 3 3 3 3 3 ## X713 X446 X693 X1116 X2934 X486 X613 X1176 X2887 X1347 X1620 X1670 X144 ## 2 1 0 3 0 4 8 4 4 3 3 3 2 ## X2600 X2839 X88 X489 X631 X1936 X545 X775 X1138 X2285 X1399 X2831 X973 ## 2 2 2 2 7 1 5 5 9 5 2 2 3 ## X1387 X84 X1507 X1880 X2627 X2782 X637 X1395 X1511 X337 X1268 X1811 X572 ## 3 6 7 8 4 4 3 3 3 3 3 5 3 ## X2705 X2903 X1510 X2634 X1041 X1196 X1342 X1633 X2855 X935 X2120 X718 X2957 ## 7 3 3 1 6 4 5 1 1 3 1 2 2 ## X403 X581 X1538 X1749 X414 X824 X1164 X2035 X2345 X55 X982 X1520 X1108 ## 10 4 4 4 5 5 7 11 5 2 2 2 3 ## X2343 X2958 X247 X2123 X2459 X483 X1813 X1984 X2460 X1926 X190 X2660 X2975 ## 3 3 2 2 2 6 4 4 4 0 2 2 2 ## X150 X391 X1231 X1230 X1911 X1033 X1225 X1422 X1537 X1255 X1777 X2854 X559 ## 3 3 3 4 2 0 3 3 3 4 9 9 0 ## X442 X1976 X746 X2929 X1047 X1355 X1546 X2724 X2623 X366 X1328 X2645 X977 ## 2 0 1 1 3 3 3 3 0 8 4 6 1 ## X2301 X1663 X2130 X2734 X71 X2000 X1351 X2248 X2987 X980 X2841 X240 X496 ## 1 0 1 1 1 1 6 4 4 1 1 3 3 ## X590 X1941 X106 X950 X1577 X1839 X1701 X1987 X2584 X288 X2725 X1297 X280 ## 3 13 3 3 3 3 2 2 4 1 1 0 0 ## X1586 X1646 X2481 X38 X1118 X1559 X2861 X2868 X1909 X2414 X2588 X2846 X1895 ## 2 2 6 3 3 2 2 2 3 3 3 5 1 ## X2919 X1256 X2443 X1840 X2591 X2672 X241 X2399 X1492 X1556 X2954 X2181 X448 ## 1 1 5 3 3 3 1 1 2 4 2 0 2 ## X2236 X2336 X253 X415 X1515 X2004 X2680 X1684 X2721 X861 X612 X1698 X2042 ## 3 2 5 5 10 5 5 1 1 0 4 4 10 ## X2320 X226 X1082 X1312 X2055 X872 X1900 X258 X619 X1627 X204 X2274 X18 ## 4 4 4 4 4 1 1 2 2 0 2 2 3 ## X1480 X2101 X1150 X353 X797 X949 X95 X1075 X1956 X547 X1644 X2169 X2568 ## 3 3 0 3 3 3 2 2 3 4 3 3 3 ## X396 X430 X710 X1501 X2675 X79 X209 X1806 X1974 X1513 X752 X2653 X2974 ## 4 4 4 4 4 5 5 5 5 0 1 1 0 ## X140 X1315 X2216 X2368 X422 X531 X2059 X610 X2087 X289 X1787 X2469 X735 ## 4 4 4 0 2 2 1 3 3 2 2 2 2 ## X1761 X128 X2201 X1796 X2316 X2871 X864 X342 X513 X1092 X297 X1089 X1250 ## 2 1 1 2 2 2 1 2 4 2 5 5 5 ## X1411 X2333 X2574 X2163 X2381 X74 X1248 X1348 X1930 X2212 X225 X2681 X2798 ## 5 5 5 4 4 6 6 6 6 6 4 4 1 ## X565 X575 X2295 X2319 X2860 X99 X1403 X2254 X1228 X1877 X194 X2026 X2528 ## 6 6 6 6 6 4 4 8 1 1 2 5 2 ## X2995 X2583 X2775 X2196 X383 X1385 X2816 X1742 X2125 X2327 X2833 X862 X1999 ## 4 2 2 0 2 2 2 8 4 4 4 2 2 ## X881 X1505 X2691 X17 X1950 X2430 X2607 X2827 X939 X1187 X1972 X2429 X1988 ## 2 2 2 4 6 4 3 3 4 4 4 4 5 ## X2557 X2659 X773 X473 X1630 X1265 X1373 X2376 X2594 X2663 X2877 X283 X1210 ## 2 2 1 2 2 6 2 0 2 2 2 2 2 ## X1304 X76 X389 X726 X2279 X2293 X1975 X2109 X571 X2100 X742 X924 X2307 ## 2 12 10 6 6 6 1 1 3 3 3 3 3 ## X2322 X722 X740 X921 X1502 X1706 X1168 X265 X856 X2598 X2640 X1907 X2282 ## 3 4 4 4 4 4 0 4 4 4 4 4 4 ## X130 X173 X1692 X1709 X1867 X2900 X999 X85 X2911 X741 X2256 X874 X2847 ## 6 6 6 6 6 1 1 2 2 2 1 2 2 ## X2124 X379 X900 X1921 X14 X2990 X686 X1803 X36 X148 X627 X2340 X2401 ## 1 2 2 1 2 2 2 2 1 1 4 8 4 ## X1525 X292 X925 X1167 X1939 X2242 X996 X2210 X2927 X1826 X302 X2768 X2043 ## 0 4 4 4 4 4 2 2 2 1 1 1 0 ## X1614 X2162 X162 X242 X933 X1621 X268 X830 X1317 X1524 X1585 X322 X616 ## 2 2 4 4 4 1 1 1 7 2 2 4 4 ## X771 X1404 X2261 X834 X2313 X2615 X1432 X1491 X1715 X1599 X2273 X2318 X2139 ## 4 4 4 2 2 2 1 1 0 4 4 4 0 ## X519 X1963 X395 X1037 X1005 X1356 X1381 X2795 X1955 X228 X2377 X388 X257 ## 2 2 2 2 3 3 3 2 0 2 6 2 1 ## X603 X1786 X639 X695 X2657 X650 X1872 X1449 X347 X1923 X2527 X782 X1474 ## 4 4 4 4 4 3 3 1 2 1 0 4 4 ## X855 X1545 X1775 X599 X2545 X2575 X360 X954 X1398 X2424 X2761 X300 X629 ## 2 2 2 1 1 1 3 3 3 6 6 4 4 ## X846 X2105 X1060 X1616 X205 X299 X104 X458 X2758 X1696 X1967 X2531 X987 ## 4 4 2 4 2 2 4 4 4 3 3 3 3 ## X2005 X2030 X2382 X487 X2766 X51 X1971 X1889 X1073 X1208 X1420 X2823 X370 ## 3 3 3 1 1 2 2 1 6 3 3 3 2 ## X1571 X2829 X753 X200 X206 X890 X1065 X2036 X382 X2032 X2252 X2356 X1899 ## 2 2 0 2 2 2 3 3 3 3 3 3 2 ## X432 X2673 X600 X963 X1045 X40 X423 X1657 X2669 X2722 X1123 X1552 X1566 ## 1 1 3 3 3 0 3 3 3 2 3 3 3 ## X1827 X1792 X2573 X1 X1568 X2388 X2695 X41 X278 X341 X447 X2939 X2165 ## 3 3 3 4 4 4 4 6 6 6 6 6 2 ## X2618 X188 X356 X666 X2362 X910 X1070 X1655 X1904 X1015 X2091 X1027 X1799 ## 2 1 1 1 1 8 5 5 2 1 0 1 1 ## X1413 X1729 X2253 X10 X739 X821 X1091 X1325 X2158 X1332 X484 X1218 X2095 ## 2 2 2 5 5 5 7 5 5 0 6 6 6 ## X1719 X1932 X1727 X1835 X2978 X2375 X968 X2777 X597 X1222 X1549 X2713 X125 ## 3 3 0 2 3 0 3 3 4 4 4 4 2 ## X309 X2170 X441 X2013 X155 X378 ## 2 0 1 1 1 1 "],["network-construction.html", "Chapter 4 Network Construction 4.1 Network Construction Process 4.2 Analysis 4.3 Centrality Measures Report 4.4 Preliminary Conclusions", " Chapter 4 Network Construction 4.1 Network Construction Process Below are the steps for calculating the “gene score” of each location that quantifies the degree of association between a base position and the disease/trait of interest. A higher score means a stronger association. For each position \\(g\\), we performed marginal regression and obtain a p-value, \\(p_g\\). Every position then is assigned a score \\(\\sigma(g) = -2log(p_g)\\) (Vandin et al., 2012). Two positions share an edge if they occur together, and the edge weight is their co-occurrence number. # record p values for each position mutations_pVal = c() disease_status_vector = c(rep(1,n/2),rep(0,n/2)) # Arbitrarily assign the first half with disease for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_vector&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) mutations_pVal = c(mutations_pVal,summary(model)$coefficient[,4][2]) } # compute score for each mutated position mutations_score &lt;- -2*log(mutations_pVal) edges = melt(A) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;%mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type, Weight) %&gt;% filter(Weight != 0) nodes = as.data.frame(colnames(sub_data))%&gt;%mutate(Lable= colnames(sub_data)) colnames(nodes) = c(&quot;Id&quot;,&quot;Lable&quot;) A.dat = as.data.frame(A) 4.2 Analysis After revising our simulation methodology, we simulated using 3000 base positions and 500 samples to obtain the following graphs. 12 of the 15 previously identified SNP locations are chosen to be part of at least one genetic pathway: X520, X521, X526, X1237, X1320, X1533, X1627, X2075, X2106, X2699, X2766, and X2881. These 12 effective SNP locations form 4 causal pathways that lead to the disease: X2699, X1320, X520, X2881 X2766, X1237, X2075, X521, X526 X526, X2766, X2106, X2075, X1533 X2699, X521, X2881, X1533, X1627 After a round of random mutations, we obtain 1187 mutated positions in total. This gives us an undirected weighted graph with 1187 nodes and 2838 edges, which produces an average degree of4.78. There is a single major component containing roughly 65% of its nodes. Expectedly, all causal pathways identified beforehand exist within this major connected component. Figure 4.1 shows the full graph, while Figure 4.2 shows its single major component. Using a resolution of 1, we obtained 25 modularity classes within the major connected component. The 12 selected positions are divided between two largest modules. \\[\\text{Figure} \\; 4.1 :\\; \\text{Full Network of Mutated Gene Base Positions}\\] \\[\\text{Figure} \\; 4.2 :\\; \\text {Modularity Class Decomposition within the Major Connected Component, with Nodes Sized According to Closeness Centrality}\\] 4.3 Centrality Measures Report Table 4.1 reports the top 12 nodes ranked by their degrees, eigenvector centrality, closeness centrality and betweeness centrality. The 12 effective disease-related positions selected are exactly the top 12 nodes with the greatest degrees and eigenvector centrality. This might be a result of the high degree of inter-connectivity among these positions. As a comparison, the \\(8^{th}\\), \\(10^{th}\\), and \\(12^{th}\\) nodes with the highest closeness centrality are random variations, while 8 of the top 12 nodes with the greatest betweenness centrality are random variations. Nodes colored blue below are random variables; nodes colored in red are nodes representing 12 SNP locations, where each is part of at least one combination. Rank Degree Eigenvector Centrality Closeness Centrality Betweeness Centrality 1 X2699 X2881 X2881 X2881 2 X2881 X2699 X2699 X2699 3 X521 X521 X1533 X1533 4 X2075 X1533 X520 X807 5 X2766 X2075 X1320 X2083 6 X526 X2766 X521 X2438 7 X1533 X526 X2075 X2251 8 X520 X520 X2766 X1301 9 X1320 X1320 X526 X1806 10 X1237 X1627 X39 X1739 11 X1627 X1237 X1627 X521 12 X2106 X2106 X1889 X571 \\[\\text{Tabble 4.1: Top 12 nodes with the highest degree, eigenvector centrality, closeness centrality and betweenness centrality}\\] 4.4 Preliminary Conclusions In this chapter, we found the exact 12 SNP locations that make up variant combinations. Network Science is powerful! Here comes the question: Why don’t we simply use degree centrality and eigenvector centrality to detect the SNP locations then? Why don’t we stop here? There are three reasons: Our goal is to not only find which mutations cause diseases, but also which combinations cause diseases. The centrality measures we have do not allow us to infer the structure of the subnetwork of 12 nodes. Our simulation uses co-occurrence counts to build edges, while in reality there could be more intrinsic ways to determine edges between SNPs. We choose the top 12 nodes for centrality measures because we know the underlying truth that there should be 12 SNP locations from our simulation. It is difficult to find a cutoff without knowing the exact number of SNP locations involved, provided that a distinguishable gap in centrality measures (in this case, between 12th and 13th) does not exist. "],["enhanced-influence-model.html", "Chapter 5 Enhanced Influence Model 5.1 Graph Diffusion Kernel 5.2 Enhanced Influence Model 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) 5.4 Alternative Situation 5.5 Code", " Chapter 5 Enhanced Influence Model After having a primary look at the network constructed using our simulated data, we moved on to use the Enhanced Influence Model to identify significant subnetworks within the graph that shed light on genetic causal pathways, which takes into consideration both the significance of individual genes with respect to the disease as well as the network topology. 5.1 Graph Diffusion Kernel We computed the graph diffusion kernel as the first step to apply the Enhanced Influence Model, which measure the extent of mutual interaction between genes in our network. Note that the obtained graph diffusion kernel is solely dependent on our network structure. The idea of graph diffusion kernels bears resemblance to random walks from a source.Here we imagine that the importance of nodes flows along edges. Initially, query nodes are selected to serve as sources where fluid is pumped in at a constant rate that flows along edges. In addition, we assume that fluid leaks out of each node at a constant rate \\(\\gamma\\). Intuitively, large \\(\\gamma\\) means faster rate of loss and therefore shorter diffusive paths. At equilibrium, there is no net flow in the entire network. The more interaction a node has with the query nodes, the more fluid it will contain at the equilibrium (Qi et al., 2008). Following the procedure in previous literature (Vandin, Upfal, and Raphael, 2011), we set \\(\\gamma = 5\\), which is approximately the average degree of a node in our network. Mathematically,let \\(u(t)\\) denotes the unit step function where \\[u(t) = \\begin{cases}0 \\;\\text{ if }\\;t&lt;0\\\\1 \\;\\text{ if }\\;t&gt;0 \\end{cases},\\] and \\(b_i = 1\\) if i is the source node of interest while \\(b_i = 0\\) otherwise. The amount of fluid contained by node \\(i\\) at time t is \\(x_i(t)\\) is governed by the flow in and out of it, \\[\\frac{d}{dt}x_i(t) = \\sum_j A_{ij}x_j(t)-\\sum_jA_{ji}x_i(t)-\\gamma x_i(t)\\] As \\(t\\to \\infty\\), the fluid distribution approaches to its equilibrium distribution at which the influence of node \\(i\\) to other nodes is measured by \\[L_\\gamma^{-1}\\vec{b_i}\\] where \\(\\vec{b_i}\\) is the standard basis with 1 at its \\(i^{th}\\) entry. Here, \\(L_\\gamma = S-A+\\gamma I\\) is the shifted graph Laplacian by \\(\\gamma\\) where \\(S\\) is the diagonal matrix whose diagonal entries are the corresponding degrees. In practice, we normalize A symmetrically by \\(S^{-\\frac{1}{2}}AS^{-\\frac{1}{2}}\\) such that the edge weights between two nodes are normalized by the degrees and replace \\(S\\) correspondingly to obtain the Laplacian (Qi et al. 2008). Here, the \\(ij\\) entry of \\(L_\\gamma^{-1}\\) gives the influence of \\(j\\) on \\(i\\), which may or may not equal to the \\(ji\\) entry of \\(L_\\gamma^{-1}\\). To better interpret the result, we define the mutual influence between i and j to be \\(\\tilde{i}(i,j) = \\min(L_\\gamma^{-1}[i,j],L_\\gamma^{-1}[j,i])\\). (Vandin, Upfal, and Raphael, 2011) 5.2 Enhanced Influence Model Enhanced Influence Model is an efficient algorithm to identify a significantly mutated subnetwork with respect to gene interactions by incorporating considerations of both the topology of the network and significance of individual genes with respect to the disease (Vandin, Upfal, and Raphael, 2011). Below are the key procedures involved in the Enhanced Influence Model: Recall from Chapter 4, marginal regression gives a p-value, \\(p_i\\) for each gene \\(i\\). We then assign a score \\(\\sigma_i\\) to a gene \\(i\\) where \\(\\sigma_i = -2\\log(p_i)\\). For each pair of genes (\\(i\\),\\(j\\)), their mutual interaction is measured by \\(w(i,j) = \\max(\\sigma_i,\\sigma_j)*\\tilde{i}(i,j)\\) (Vandin et al., 2011). Next, we remove all edges with weights smaller than a threshold \\(\\delta\\) to obtain a subgraph. In Section 5.3, we shall exhibit a method to determine this cold-edge threshold \\(\\delta\\). The connected components remained are candidates for genetic pathways. The code below shows how we construct the enhanced influence model from scratch. # normalize A A_normalized &lt;- matrix(0,nrow(A),nrow(A)) for(i in 1:(nrow(A)-1)){ for(j in i:nrow(A)){ if(deg[i]!=0 &amp;&amp; deg[j]!=0){ A_normalized[i,j] &lt;- A[i,j]/sqrt(deg[i]*deg[j]) } } } A_normalized &lt;- forceSymmetric(A_normalized,&quot;U&quot;) A_normalized &lt;- as.matrix(A_normalized) # normalize the corresponding degree matrix S S_normalized &lt;- diag(rowSums(A_normalized)) gamma &lt;- 5 L_gamma &lt;- S_normalized+diag(gamma,nrow(A))-A_normalized inv_L_gamma &lt;- solve(L_gamma) # compute symmetric importance score using Enhanced Influence Model W &lt;- matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W[i,j] &lt;- min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(mutations_score[i],mutations_score[j]) } } # helper function to remove cold_edge removeColdEdge &lt;- function(mat,W,delta){ hotnet &lt;- mat for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ if(W[i,j]&lt;delta){ hotnet[i,j] = 0 } } } return(hotnet) } Hotnet &lt;- removeColdEdge(A_normalized,W,0.04) Hotnet &lt;- as.matrix(forceSymmetric(Hotnet,&quot;U&quot;)) colnames(Hotnet) &lt;- position rownames(Hotnet) &lt;- position HotEdges &lt;- melt(Hotnet) %&gt;% rename(Source = Var1, Target = Var2, Weight = value) %&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0) %&gt;% select(-Weight) edges.copy &lt;- edges edges.copy &lt;- edges.copy %&gt;% select(Source,Target) colnames(edges.copy) &lt;- c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) # get a list of connected components clu &lt;- components(g) res &lt;- groups(clu) getNumComp &lt;- function(edges,nodes,s){ edges.copy = edges edges.copy = edges.copy%&gt;%select(Source,Target) colnames(edges.copy) = c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) clu &lt;- components(g) res &lt;- groups(clu) count &lt;- 0 for(i in 1:length(res)){ if(length(res[[i]]) &gt;= s){ count = count+1 } } return(count) } 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) In this section, we illustrate a way to determine the value for \\(\\delta\\). We start with simulating 50 datasets under \\(H_0^P\\) by permuting observed disease status. (Vandin et. al, 2012) Then, for a small value of \\(s\\), where often \\(s \\in \\{3,4,5\\}\\), we choose the first \\(\\delta\\) that gives the largest number of subnetworks of size at least \\(s\\). Given the size of our network, we use \\(s = 3\\). Table 5.1 report the number of connected components of size at least 3 as a function of \\(\\delta\\). delta value 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 Num.Components, Size&gt;3 100.30 118.10 50.20 10.50 2.40 2.40 2.40 0.00 0.00 \\[\\text{Table 5.1: Number of Components of Size at Least 3 as a Function of} \\;\\delta\\] According to Vandin (2012), an empirical choice is using a first \\(\\delta\\) that gives the maximum number of connected components of size at least 3, which gives \\(\\delta = 0.02\\) in our case. Since increasing \\(\\delta\\) gives us more conservative criteria, we also consider the following values: \\(1.5\\delta = 0.03, 2\\delta = 0.04, 3\\delta = 0.06, 4\\delta = 0.08\\). In fact, if \\(\\delta_1 &gt;\\delta_2\\), then the connected components of size at least 3 obtained using \\(\\delta_2\\) will be subnetworks of those obtained using \\(\\delta_1\\). We applied the above \\(\\delta\\) values to filter the edges and obtained 5 graphs using the graph presented in Chapter 4. Intuitively, as we raise the value for \\(\\delta\\), there will be more isolated nodes and the size of major component will decrease as it gets decomposed into smaller parts. We expect the the true causal pathways will be among the connected components after applying the Enhanced Influence Model and filtering the edges. Figures 5.1 (a) - (e) shows their corresponding major components, which contained the 4 genetic causal pathways listed in Chapter 4. Nodes are sized by closeness centrality throughout our analysis. \\[\\text{Figure 5.1(a): Major component of the network of mutated genes when delta = 0.02}\\] \\[\\text{Nodes Sized by Closeness Centrality}\\] \\[\\text{Figure 5.1(b): Major component of the network of mutated genes when delta = 0.03}\\] \\[\\text{Figure 5.1(c): Major component of the network of mutated genes when delta = 0.04}\\] \\[\\text{Figure 5.1(d): Major component of the network of mutated genes when delta = 0.06}\\] \\[\\text{Figure 5.1(e): Major component of the network of mutated genes when delta = 0.0}\\] We found that at \\(\\delta = 0.04\\) and \\(\\delta= 0.06\\), the major component both contains precisely the 12 SNP locations that were part of at least one pathway interaction combination. To determine which one of the two is better, we go back to the four original pathways and evaluate their quality. It seems that the major component more accurately describes the truth when \\(\\delta = 0.04\\), as presented below. \\[\\text{Figure 5.2: Modularity Class Breakdown within the Major Component when delta = 0.04}\\] Figure 5.2 shows after modularity decomposition, our algorithm successfully captures most of the structures of the 4 pre-selected genetic pathways we listed in Chapter 4.2. The pink modularity class corresponds perfectly to the first pathway (X2699, X1320, X520, X2881); out of the 5 nodes classified in the orange modularity class, 4 of them come from the second pathway (X2766, X1237, X2075, X521, X526) and 4 from the third pathway (X526, X2766, X2106, X2075, X1533); the 3 nodes in the green modularity class are 3 of the 5 SNP locations from the fourth pathway (X2699, X521, X2881, X1533, X1627). Note that nodes with high closeness centralities such as X521, X1533, and X2699 happen to be those SNP locations shared by multiple pathways. The fact that the fourth pathway captured by our algorithm appears to be most imperfect one might be explained by the fact that 3 of its components are shared with other pathways. As our algorithm obtains subgraphs by removing edges, we conjecture that shared SNP locations by multiple pathways makes the it hard for the algorithm to make a perfect division between pathways. To confirm our thought, we simulated dataset under a simplied situation where no two pathways share a mutural SNP location and presented the results below. 5.4 Alternative Situation In the previous section, we find that our method is confused about which modularity class a certain node belongs to. We hypothesize that this may be due to that the node makes up more than one combination of pathway interactions. We wonder if the problem will arise when each mutation only contributes to one pathway combination (denoted as Scenario B). If the problem universally happens, we need to analyze its cause. We repeated the process, with a twist in the construction of the original dataset. We simulated a dataset where no two pathways share a SNP location. Random simulation gives the following 4 causal genetic pathways: X2608, X182, X1443, X624, X2422 X2454, X1099, X350, X2548, X883 X31, X2725, X608, X471 X815, X2108, X2494, X2812, X1245 Figure 5.3 shows the full network of SNP locations where at least one mutation occurs where the purple part is the largest connected component. \\[\\text{Figure 5.3: Figure Full Network of Mutated Genes under Scenario B}\\] delta value 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 Num.Components, Size&gt;3 100.30 118.10 50.20 10.50 2.40 2.40 2.40 0.00 0.00 \\[\\text{Table 5.2: Number of Components of Size at Least 3 as a Function of} \\;\\delta \\;\\text{under Scenario B}\\] The empirical choice \\(\\delta&#39; = 0.04\\) gives the first mamimum average number of connected components of size at least 3. Experimenting with \\(\\delta = 1.5\\delta&#39;\\) and \\(\\delta = 2\\delta&#39;\\) shows that \\(\\delta = 2\\delta&#39;=0.08\\) gives a perfect fit. Figure 5.4 shows the filtered network obtained from Figure 5.3 using \\(\\delta = 0.08\\). Observe that there is no single major connected components. However, all four pathways exist as independent connected components that are colored in Figure 5.4. Figure 5.5 shows the the filtered graph for the four components. All 4 pathwaysa re identified, which supplies proof for the validity of our method. \\[\\text{Figure 5.4: Resulted Network using}\\; \\delta=0.08 \\;\\text{under Scenario B}\\] \\[\\text{Figure 5.5: All 4 Pathways Identified under Scenario B}\\] 5.5 Code Below is the code that supports our work in this chapter. disease_status_mat &lt;- matrix(NA,50,500) for(i in 1:50){ disease_status_mat[i,] &lt;- permute(disease_status_vector) } pVal.lst &lt;- list() for(k in 1:50){ res &lt;- c() for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_mat[k,]&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) res &lt;- c(res,summary(model)$coefficient[,4][2]) pVal.lst[[k]] = res } } score.lst = list() for(k in 1:50){ score.lst[[k]] = -2*log(pVal.lst[[k]]) } W.lst = list() for(k in 1:50){ W.lst[[k]] = matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W.lst[[k]][i,j] = min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(score.lst[[k]][i],score.lst[[k]][j]) } } } aveNumComp_s &lt;- function(delta, s=3){ # list of adjacency matrices for HotNet for 50 datasets under the null hypothesis # under the given threshold delta Hotnet.lst = list() for(k in 1:10){ Hotnet.lst[[k]] = removeColdEdge(A_normalized,W.lst[[k]],delta) Hotnet.lst[[k]] = as.matrix(forceSymmetric(Hotnet.lst[[k]],&quot;U&quot;)) } HotEdges.lst = list() for(k in 1:10){ colnames(Hotnet.lst[[k]]) = position rownames(Hotnet.lst[[k]]) = position HotEdges.lst[[k]]= melt(Hotnet.lst[[k]]) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0)%&gt;%select(-Weight) } numComp_s = rep(0,10) for(k in 1:10){ numComp_s[k] = getNumComp(HotEdges.lst[[k]],nodes,s) } return(mean(numComp_s)) } x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=3) x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=2) "],["discussion-and-future-work.html", "Chapter 6 Discussion and Future Work 6.1 What did we achieve? 6.2 Limitations 6.3 Future Work", " Chapter 6 Discussion and Future Work 6.1 What did we achieve? The most exciting part of this project to us is using network science to solve real-life problems. Genetics is such an complex topic and affects every part of who we are. Given how chemistry works in our body, it is hard to imagine that we could accurately quantify how genes interact with each other. But we are excited to learn that with some basic assumptions, one could have some predicting power with mathematical tools, even though we have to leave out many details in our modeling process. The takeaway is that we are able to model how pathway interactions cause diseases and use network science tools to detect such pathways. Our assumption states that diseases/traits can be caused by a combination of mutations at SNP locations, and one mutation may be involved in multiple combinations. This poses an inherent challenge for network analysis: it is hard to classify which modularity class that such mutations should belong to. However, we present that our method perfectly classifies different pathway interactions if one mutation could only exist in one combination. 6.2 Limitations A major limitation, as discussed above, is the adherence to biological facts. It is not feasible to exactly replicate the complex biochemical processes along the DNA sequence, and thus our assumptions bear the risk of not representing the reality. During our analysis, we first pre-determined which combinations of variants along the genome could lead to the disease/trait. However, we do not know the underlying true combinations of pathway interactions in real life. When implementing our algorithm in a more realistic setting, we may have difficulty interpreting the validity of the result. For example, in Chapter 4, we see that our method perfectly detects the combination “X2699, X1320, X520, X2881”, and yields slight discrepancies in other combinations. Thus, it is important to test the algorithm in different settings and better understand how the results may be impacted. In addition, many inputs of our method are chosen relatively arbitrarily based on existing literature. We attempted many different values for variables including total SNP locations and the number of combinations. It is, however, important to note that we could not test all potential values for all variables. We would like to understand changes in our algorithm’s accuracy if we have a larger number of SNP locations or more possible combinations etc. 6.3 Future Work Given the time constraint, many interesting problems and extensions remain to be explored and discussed. Below we list two possible directions to furnish our project: We mentioned earlier is how we can incorporate two disease/traits and their corresponding pathways and check if our method accurately detects both pathways under a different setting of noises. In addition, there may be other tools designed for our setting, which may incorporate work from network science, statistical genetics or computational biology. For example, as any connected component could be a candidate for a causal genetic pathway, using false discovery rates, the statistical significance of the overall findings could be evaluated (Vandin et al., 2012). "],["references.html", "Chapter 7 References", " Chapter 7 References Leiserson, M. D., Eldridge, J. V., Ramachandran, S., &amp; Raphael, B. J. (2013). Network analysis of GWAS data. Current opinion in genetics &amp; development, 23(6), 602-610. https://doi.org/10.1016/j.gde.2013.09.003 Vandin, F., Clay, P., Upfal, E., &amp; Raphael, B. J. (2012). Discovery of mutated subnetworks associated with clinical data in cancer. Pacific Symposium on Biocomputing. Pacific Symposium on Biocomputing, 55-66. Vandin, F., Upfal, E., &amp; Raphael, B. J. (2011). Algorithms for detecting significantly mutated pathways in cancer. Journal of computational biology : a journal of computational molecular cell biology, 18(3), 507-522. https://doi.org/10.1089/cmb.2010.0265 Qi, Y., Suhail, Y., Lin, Y. Y., Boeke, J. D., &amp; Bader, J. S. (2008). Finding friends and enemies in an enemies-only network: a graph diffusion kernel for predicting novel genetic interactions and co-complex membership from yeast genetic interactions. Genome research, 18(12), 1991-2004. https://doi.org/10.1101/gr.077693.108 What Are Single Nucleotide Polymorphisms (SNPs)? (n.d.). Retrieved from https://medlineplus.gov/genetics/understanding/genomicresearch/snp/ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= fc9bc3389f10c78caadaa9d56096928a52c78f21 "]]
