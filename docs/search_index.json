[["index.html", "MATH 479 Network Science Project Preface", " MATH 479 Network Science Project Zhaoheng Li and Zuofu Huang, Fall 2020 Macalester College Preface Hello! Welcome to our final project of Network Science! This bookdown is a work in progress, and please check back early and often (as much as people do to their Github code). Feel free to contact us if you have any questions! Now that we are in the realm of networks, we feel compelled to motivate our project with an xkcd comic related to networks. Credit to xkcd: https://xkcd.com/350/ "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction We are motivated by existing genetic association studies that find the correlation between certain diseases/traits and genetic variants (SNP mutations). We wonder if network analysis can be utilized in the process of genome-wide association studies. Genome wide association studies (GWAS) is a method for identifying the associations between certain genetic regions called loci and one’s trait. Usually among the traits, we are interested in the disease status. Later, we came across the paper named Network Analysis of GWAS data (Leiserson et. al, 2013), where we first saw the connection made between genetics and network science. This motivates our attempt of finding genetic pathway interactions for a certain disease/trait. Intuitively, we would like to think of the simplified scenario: a certain disease can be caused by several genetic pathways. Suppose we have \\(n\\) SNP locations previously identified as related to the disease, and \\(k\\) subsets among the SNP locations that in combination cause the disease (\\(k &lt; n\\)). Our goal is to simulate data that aligns with the proposed setting, and use network science tools to identify these pathway interactions (pretending that we did not know the underlying true subsets). This process aims at testing the validity of the network science tool we propose. Looking forward, we would like to test how the tool behaves when the dataset we simulate contains genetic information for two diseases: we wonder if the algorithm is capable of picking up pathway interaction patterns for both diseases. "],["initial-steps.html", "Chapter 2 Initial Steps 2.1 Genetics Background 2.2 Simulate original data 2.3 Sample mutations for patients at SNP locations 2.4 Sample mutations for non-patients at SNP locations 2.5 Variants at non-SNP locations 2.6 Screening 2.7 Marginal Regression 2.8 Discussion", " Chapter 2 Initial Steps Our initial thought was that Genome-Wide Association Studies data is readily available for public access and that we should be able to retrieve the dataset easily. However, it came unexpected that a research proposal from faculty was needed to obtain GWAS data for research purposes. Therefore, we decide to simulate our own GWAS data for the purpose of this research. 2.1 Genetics Background The human genome contains roughly 234,000 exons, 80% of which contain fewer than 200 base pairs in length. However, mutations in these exons contain a majority of mutations that are related to diseases. Our setting is structured in this context. Suppose we have a disease. It is reasonable to assume that we know where the mutations related to this disease approximately are along the genome. We guess that 1000 loci (specific position where a gene is located) could harbor the disease-related mutations. In addition, we assume that each locus on average contains 200 base pairs (a pair of complementary bases in a double-stranded DNA: A-T, G-C), which corresponds to locus_length &lt;- 200 in the code. loci &lt;- 1000 locus_length &lt;- 200 2.2 Simulate original data We start by creating the dataset. Everyone row is set to the reference level first (i.e. there is no variant). Suppose initially we have 500 individuals, and we categorize 100 as people who have the disease. n &lt;- 500 n_disease &lt;- 100 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = loci*locus_length, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = loci * locus_length,byrow = TRUE)) SNP_location &lt;- sample(1:(loci*locus_length), size = 50, replace = FALSE) reference_level_SNP_location &lt;- reference[SNP_location] 2.3 Sample mutations for patients at SNP locations We then sample mutations at SNP locations who were categorized as patients. disease_people_row_number &lt;- sample(1:500, 100, replace = FALSE) combo_number &lt;- 15 SNP_number &lt;- sample(1:6, combo_number, replace = TRUE) disease_combo &lt;- list() for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) #helper functions for decomposition. helper2 &lt;- function(char){ other_set &lt;- setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;G&quot;,&quot;C&quot;),char) return(sample(other_set,1)) } helper3 &lt;- function(char, p = 0.15){ random &lt;- runif(1) if (random &lt;= (1-3*p)){ return(char) } else if (random &lt;= 1-2*p){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[1]) } else if (random &lt;= (1-p)){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[2]) } else { return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[3]) } } # For patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper2(reference_level_SNP_location[index[j]]) } # non-disease-related SNP mutations non_forced_index &lt;- setdiff(1:50, index) for (k in 1:length(non_forced_index)){ reference_level_SNP_location_copy[non_forced_index[k]] &lt;- helper3(reference_level_SNP_location[non_forced_index[k]],0.15) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy } 2.4 Sample mutations for non-patients at SNP locations We then hypothesize that given a common condition, non-patients are also more likely to have mutations at the SNP locations than at most other locations (e.g. those locations that make human human). # For those who are not set to have disease first (400) # Loop over 50 genes, each one has some possibility to mutate. (More likely than the other nucleotides on the genome) non_disease_row_number &lt;- setdiff(1:500,disease_people_row_number) for (i in non_disease_row_number){ for (j in SNP_location) data[i,j] &lt;- helper3(data[i,j],0.05) } 2.5 Variants at non-SNP locations The next step is simulating random noise at non-SNP locations to better mimic properties of gene mutations in real life. potential_SNP_places &lt;- SNP_location potential_random_change_sites &lt;- setdiff(1:(loci*locus_length),SNP_location) for (i in 1:n){ random_locus &lt;- sample(potential_random_change_sites, size = (loci*locus_length/1000), replace = FALSE) # definitely change for(j in random_locus){ data[i,j] &lt;- helper2(data[i,j]) potential_SNP_places &lt;- c(potential_SNP_places, random_locus) } } potential_SNP_places &lt;- unique(potential_SNP_places) 2.6 Screening With the mutations that non-patients had at SNP locations, some of the 400 people may fall into the “disease” status. We then performed a round of screening for 400 people who were initially categorized without the disease. Surprisingly, we found that a large number of people fall into the “disease” status. We were surprised for two reasons: The probability of mutations at each location is low. Even if many mutations happen for someone, a right “combination of pathways” is needed to achieve the “disease” status, which happens more often than estimated. # Do a round of screening for 400 people who did not initially have the disease NewPatient &lt;- c() for (i in non_disease_row_number){ MutatedSNP &lt;- c() for(j in SNP_location){ if(isMutated(i,j)){ MutatedSNP &lt;- c(MutatedSNP,j) } } for(k in 1:15){ if(all(disease_combo[[k]] %in% MutatedSNP)){ causalPathway &lt;- c() for(position in disease_combo[[k]]){ causalPathway = c(causalPathway,helper2(reference[position])) } if(all(data[i,position] == causalPathway)){ NewPatient &lt;- c(NewPatient,i) break } } } } disease_row_final &lt;- c(disease_people_row_number, NewPatient) disease_status_vector &lt;- rep(FALSE, 500) for (i in 1:500){ if (i %in% disease_row_final){ disease_status_vector[i] &lt;- TRUE } } 2.7 Marginal Regression Once we have simulated potential variants for everyone at every location, we find all places that at least one person has a variation at, select the places and fit a marginal regression at each location against the disease status. for (i in potential_SNP_places){ reference_level_here &lt;- reference[i] for (j in 1:n){ if (data[j,i] == reference_level_here){ data[j,i] &lt;- TRUE } else { data[j,i] &lt;- FALSE } } } subdata &lt;- data[,potential_SNP_places] isMutated &lt;- function(person,position){ if(data[person,position] == reference[position] ){ return(FALSE) } else{ return(TRUE) } } for (i in potential_SNP_places){ summary(lm(disease_status_vector ~ data[,i])) } 2.8 Discussion Problems with this approach, as we realized later, were that: We assumed genetic variant was the only reason people had the disease, which was almost never the case. People who were initially categorized as non-patients and later have their status changed are more than we expected. This casts doubt on the necessity of pre-determining the number of patients (100 in this case). Our approach was not fully supported by pre-existing literature. We pasted pieces of several literature into this approach. The probability of mutations at each location was also not documented. When we are simulating random variants, we set the number of changes to be size = (loci*locus_length/1000) as we believed the average probability of SNP is 1/1000. However, this is faulty because the size was fixed at the expected value of the number of mutation sites, without allowing any difference across individuals. Let \\(\\text{X = number of variants}\\) and \\(\\text{n = number of locations}\\). \\(X\\) follows the distribution: \\(X \\sim Bin(n,p)\\). However, \\(X\\) can vary as we draw from the Binomial distribution. With the reasons above, we keep digging into the literature and test potential alternatives. "],["progress-and-revision.html", "Chapter 3 Progress and Revision 3.1 Rationale 3.2 Updated Code", " Chapter 3 Progress and Revision 3.1 Rationale When we found out that only SNP locations can be categorized as significant and other loci are exclusively “non-significant”, we realized that we are getting too far into simulation. Although it seemed that every step we take is justified, the simulated data seem unrealistic and overfitting for our scenario. As we were conducting a more extensive literature review process in the hope of shedding light on the next simulation steps, we came across the paper Discovery of Mutated Subnetworks Associated with Clinical Data in Cancer (Vandin et. al, 2012). Section 3.1 of the paper contains a description of how the data is simulated in a slightly different setting. There are a few notable changes that we implemented in the Progress and Revision section. We argue that a common disease can be caused by both genetic variants and external environmental factors, as opposed to the genetic variations alone in our previous simulations. Therefore, we can pre-determine the number of people whose diseases are caused by genetic factors (as the paper suggested, 20% of people who carry the disease). The value of \\(p\\) is determined by the biological background that on average the probability of having a mutation at each location is \\(1/1000\\), as described in What Are Single Nucleotide Polymorphisms (SNPs)? (n.d.). For people whose diseases are caused by genetic factors: the probability of mutations at every other location (including SNP locations that were not in their combination) has a probability of \\(p = 1/1000\\). For people whose diseases are caused by non-genetic factors: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For people who do not have the disease: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For the purpose of the simulation, we combine the group of people whose diseases are caused by non-genetic factors and the group of people who do not carry the disease. Suppose we have a total of 500 people, half of which do not carry the disease. Then the total number of people whose disease are caused by genetic factors is 10% of the total population, as seen in n_disease &lt;- 0.1*n in the Update Code section below. We determine that there are 4 combinations of genetic pathways that cause the disease (which is much more realistic than 15 pathways). Each of the pathway contains a random group of 4-5 variants chosen from 15 SNP locations. The variant could be present in more than one pathway or none of the pathways. We replace the multiplication of loci and locus_length with a total position of 3000. We argue that reducing the number of loci does not change our inference process. As we test the validity of the approach, we then have the freedom of increasing the dimension (column) of the dataset or incorporating another disease/trait and its corresponding genetic pathways in our analysis. 3.2 Updated Code n &lt;- 500 n_disease &lt;- n*0.1 total_position &lt;- 3000 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = total_position, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = total_position,byrow=TRUE)) disease_people_row_number &lt;-seq(1,n_disease) non_disease &lt;- seq((n_disease+1),n) combo_number &lt;- 4 disease_combo &lt;- list() SNP_number &lt;- sample(4:5, combo_number, replace = TRUE) SNP_location &lt;- sample(1:total_position, 15, replace = FALSE) for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } reference_level_SNP_location &lt;- reference[SNP_location] disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) helper &lt;- function(char){ return(sample(setdiff(c(&quot;A&quot;,&quot;C&quot;,&quot;T&quot;,&quot;G&quot;),char),1)) } # function to mutate positions not in the identified pathways mutater &lt;- function(vec,non_position){ mutated &lt;- c() for (i in 1:length(vec)){ if (! i %in% non_position){ rand &lt;- runif(1) if (rand &lt;= 10^{-3}){ vec[i] &lt;- helper(vec[i]) mutated &lt;- c(mutated, i) } } } return(list(vec,mutated)) } # all mutated positions mutated_position &lt;- SNP_location # keep track of mutated positions for each subject to record co-occurrence frequency of mutations # For causal-pathway-related patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper(reference_level_SNP_location[index[j]]) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy # random change mutated_result &lt;- mutater(data[i,],thiscombo) data[i,] &lt;- mutated_result[[1]] # update the list of all positions that mutated mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } # for everyone else for (k in (n_disease+1):n){ # update mutated positions mutated_result &lt;- mutater(data[k,], SNP_location) data[k,] &lt;- mutated_result[[1]] mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } mutated_position &lt;- unique(mutated_position) # Delete the locations among the 15 pre-identified locations that are not selected to be part of a causal pathway del &lt;- c() for(p in mutated_position){ count &lt;- 0 if(all(data[,p]==reference[p])){ del &lt;- c(del,p) } } mutated_position &lt;- setdiff(mutated_position,del) # Create a subset of the data for all positions with at least one mutation for(position in mutated_position){ # return true if a mutation happens at the position data[,position] &lt;- !(data[,position]==reference[position]) } sub_data &lt;- data[,mutated_position] position &lt;- colnames(sub_data) Create the adjacency matrix A that contains all positions where there is at least one mutation across all subjects. A &lt;- matrix(0,length(mutated_position),length(mutated_position)) rownames(A) &lt;- colnames(sub_data) colnames(A) &lt;- colnames(sub_data) for(i in 1:nrow(sub_data)){ count = sum(sub_data[i,]==TRUE) if(count &gt;= 2){ loc &lt;- which(as.logical(as.vector(sub_data[i,])),TRUE) pairs_mat &lt;- combn(loc,2) for(j in 1:ncol(pairs_mat)){ r &lt;- pairs_mat[1,j] c &lt;- pairs_mat[2,j] A[r,c] &lt;- A[r,c]+1 } } } A &lt;- as.matrix(forceSymmetric(A,&quot;U&quot;)) Calculate the degree of the adjacency matrix. We can develop an intuitive understanding of the matrix by calculating the average degree. deg &lt;- rowSums(A) mean(deg) ## [1] 5.331637 "],["network-construction.html", "Chapter 4 Network Construction 4.1 Network Construction Process 4.2 Analysis 4.3 Centrality Measures Report 4.4 Preliminary Conclusions", " Chapter 4 Network Construction 4.1 Network Construction Process Below are the steps for calculating the “gene score” of each location that quantifies the degree of association between a base position and the disease/trait of interest. A higher score means a stronger association. For each position \\(g\\), we perform marginal regression and obtain a p-value, \\(p_g\\). Every position then is assigned a score \\(\\sigma(g) = -2log(p_g)\\) (Vandin et al., 2012). Two positions share an edge if they occur together, and the edge weight is their co-occurrence number. # record p values for each position mutations_pVal = c() disease_status_vector = c(rep(1,n/2),rep(0,n/2)) # Arbitrarily assign the first half with disease for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_vector&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) mutations_pVal = c(mutations_pVal,summary(model)$coefficient[,4][2]) } # compute score for each mutated position mutations_score &lt;- -2*log(mutations_pVal) edges &lt;- melt(A) %&gt;% rename(Source = Var1, Target = Var2, Weight = value) %&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type, Weight) %&gt;% filter(Weight != 0) nodes &lt;- as.data.frame(colnames(sub_data)) %&gt;% mutate(Label = colnames(sub_data)) colnames(nodes) &lt;- c(&quot;Id&quot;,&quot;Label&quot;) A.dat &lt;- as.data.frame(A) 4.2 Analysis After revising our simulation methodology, we simulated using 3000 base positions and 500 samples to obtain the following graphs. 12 of the 15 previously identified SNP locations are chosen to be part of at least one genetic pathway: X520, X521, X526, X1237, X1320, X1533, X1627, X2075, X2106, X2699, X2766, and X2881. These 12 effective SNP locations form 4 causal pathways that lead to the disease: X2699, X1320, X520, X2881 X2766, X1237, X2075, X521, X526 X526, X2766, X2106, X2075, X1533 X2699, X521, X2881, X1533, X1627 After a round of random mutations, we obtain 1187 mutated positions in total. This gives us an undirected weighted graph with 1187 nodes and 2838 edges, which produces an average degree of4.78. There is a single major component containing roughly 65% of its nodes. Expectedly, all causal pathways identified beforehand exist within this major connected component. Figure 4.1 shows the full graph, while Figure 4.2 shows its single major component. Using a resolution of 1, we obtained 25 modularity classes within the major connected component. The 12 selected positions are divided between two largest modules. \\[\\text{Figure} \\; 4.1 :\\; \\text{Full Network of Mutated Gene Base Positions}\\] \\[\\text{Figure} \\; 4.2 :\\; \\text {Modularity Class Decomposition within the Major Connected Component, with Nodes Sized According to Closeness Centrality}\\] 4.3 Centrality Measures Report Table 4.1 reports the top 12 nodes ranked by their degrees, eigenvector centrality, closeness centrality and betweeness centrality. The 12 effective disease-related positions selected are exactly the top 12 nodes with the greatest degrees and eigenvector centrality. This might be a result of the high degree of inter-connectivity among these positions. As a comparison, the \\(8^{th}\\), \\(10^{th}\\), and \\(12^{th}\\) nodes with the highest closeness centrality are random variations, while 8 of the top 12 nodes with the greatest betweenness centrality are random variations. Nodes colored blue below are random variables; nodes colored in red are nodes representing 12 SNP locations, where each is part of at least one combination. Rank Degree Eigenvector Centrality Closeness Centrality Betweeness Centrality 1 X2699 X2881 X2881 X2881 2 X2881 X2699 X2699 X2699 3 X521 X521 X1533 X1533 4 X2075 X1533 X520 X807 5 X2766 X2075 X1320 X2083 6 X526 X2766 X521 X2438 7 X1533 X526 X2075 X2251 8 X520 X520 X2766 X1301 9 X1320 X1320 X526 X1806 10 X1237 X1627 X39 X1739 11 X1627 X1237 X1627 X521 12 X2106 X2106 X1889 X571 \\[\\text{Table 4.1: Top 12 nodes with the highest degree, eigenvector, closeness and betweenness centrality}\\] 4.4 Preliminary Conclusions In this chapter, we found the exact 12 SNP locations that make up variant combinations. Network Science is powerful! Here comes the question: Why don’t we simply use degree centrality and eigenvector centrality to detect the SNP locations then? Why don’t we stop here? There are three reasons: Our goal is to not only find which mutations cause diseases, but also which combinations cause diseases. The centrality measures we have do not allow us to infer the structure of the subnetwork of 12 nodes. Our simulation uses co-occurrence counts to build edges, while in reality there could be more intrinsic ways to determine edges between SNPs. We choose the top 12 nodes for centrality measures because we know the underlying truth that there should be 12 SNP locations from our simulation. It is difficult to find a cutoff without knowing the exact number of SNP locations involved, provided that a distinguishable gap in centrality measures (in this case, between 12th and 13th) does not exist. "],["enhanced-influence-model.html", "Chapter 5 Enhanced Influence Model 5.1 Graph Diffusion Kernel 5.2 Enhanced Influence Model 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) 5.4 Alternative Situation 5.5 Code", " Chapter 5 Enhanced Influence Model After having a primary look at the network constructed using our simulated data, we moved on to use the Enhanced Influence Model to identify significant subnetworks within the graph that shed light on genetic causal pathways, which takes into consideration both the significance of individual genes with respect to the disease as well as the network topology. 5.1 Graph Diffusion Kernel We computed the graph diffusion kernel as the first step to apply the Enhanced Influence Model, which measure the extent of mutual interaction between genes in our network. Note that the obtained graph diffusion kernel is solely dependent on our network structure. The idea of graph diffusion kernels bears resemblance to random walks from a source. Here we imagine that the importance of nodes flows along edges. Initially, query nodes are selected to serve as sources where fluid is pumped in at a constant rate that flows along edges. In addition, we assume that fluid leaks out of each node at a constant rate \\(\\gamma\\). Intuitively, large \\(\\gamma\\) means faster rate of loss and therefore shorter diffusive paths. At equilibrium, there is no net flow in the entire network. The more interaction a node has with the query nodes, the more fluid it will contain at the equilibrium (Qi et al., 2008). Following the procedure in previous literature (Vandin, Upfal, and Raphael, 2011), we set \\(\\gamma = 5\\), which is approximately the average degree of a node in our network (See Chapter 3). Mathematically, let \\(u(t)\\) denote the unit step function where \\[u(t) = \\begin{cases}0 \\;\\text{ if }\\;t&lt;0\\\\1 \\;\\text{ if }\\;t&gt;0 \\end{cases}\\] \\(b_i = 1\\) if \\(i\\) is the source node of interest, and \\(b_i = 0\\) otherwise. The amount of fluid contained by node \\(i\\) at time t is \\(x_i(t)\\) is governed by the flow in and out of it, \\[\\frac{d}{dt}x_i(t) = \\sum_j A_{ij}x_j(t)-\\sum_jA_{ji}x_i(t)-\\gamma x_i(t)\\] As \\(t\\to \\infty\\), the fluid distribution approaches to its equilibrium distribution at which the influence of node \\(i\\) to other nodes is measured by \\[L_\\gamma^{-1}\\vec{b_i}\\] where \\(\\vec{b_i}\\) is the standard basis with 1 at its \\(i^{th}\\) entry. Here, \\(L_\\gamma = S-A+\\gamma I\\) is the shifted graph Laplacian by \\(\\gamma\\) where \\(S\\) is the diagonal matrix whose diagonal entries are the corresponding degrees. In practice, we normalize A symmetrically by \\(S^{-\\frac{1}{2}}AS^{-\\frac{1}{2}}\\) such that the edge weights between two nodes are normalized by the degrees and replace \\(S\\) correspondingly to obtain the Laplacian (Qi et al. 2008). Here, the \\(ij\\) entry of \\(L_\\gamma^{-1}\\) gives the influence of \\(j\\) on \\(i\\), which may or may not equal to the \\(ji\\) entry of \\(L_\\gamma^{-1}\\). To better interpret the result, we define the mutual influence between i and j to be \\(\\tilde{i}(i,j) = \\min(L_\\gamma^{-1}[i,j],L_\\gamma^{-1}[j,i])\\) (Vandin, Upfal, and Raphael, 2011). 5.2 Enhanced Influence Model Enhanced Influence Model is an efficient algorithm to identify a significantly mutated subnetwork with respect to gene interactions by incorporating considerations of both the topology of the network and significance of individual genes with respect to the disease (Vandin, Upfal, and Raphael, 2011). Below are the key procedures involved in the Enhanced Influence Model: Recall from Chapter 4, marginal regression gives a p-value, \\(p_i\\) for each gene \\(i\\). We then assign a score \\(\\sigma_i\\) to a gene \\(i\\) where \\(\\sigma_i = -2\\log(p_i)\\). For each pair of genes (\\(i\\),\\(j\\)), their mutual interaction is measured by \\(w(i,j) = \\max(\\sigma_i,\\sigma_j)*\\tilde{i}(i,j)\\) (Vandin et al., 2011). Next, we remove all edges with weights smaller than a threshold \\(\\delta\\) to obtain a subgraph. In Section 5.3, we shall exhibit a method to determine this cold-edge threshold \\(\\delta\\). The connected components remained are candidates for genetic pathways. The code below shows how we construct the enhanced influence model from scratch. # normalize A A_normalized &lt;- matrix(0,nrow(A),nrow(A)) for(i in 1:(nrow(A)-1)){ for(j in i:nrow(A)){ if(deg[i]!=0 &amp;&amp; deg[j]!=0){ A_normalized[i,j] &lt;- A[i,j]/sqrt(deg[i]*deg[j]) } } } A_normalized &lt;- forceSymmetric(A_normalized,&quot;U&quot;) A_normalized &lt;- as.matrix(A_normalized) # normalize the corresponding degree matrix S S_normalized &lt;- diag(rowSums(A_normalized)) gamma &lt;- 5 L_gamma &lt;- S_normalized+diag(gamma,nrow(A))-A_normalized inv_L_gamma &lt;- solve(L_gamma) # compute symmetric importance score using Enhanced Influence Model W &lt;- matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W[i,j] &lt;- min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(mutations_score[i],mutations_score[j]) } } # helper function to remove cold_edge removeColdEdge &lt;- function(mat,W,delta){ hotnet &lt;- mat for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ if(W[i,j] &lt; delta){ hotnet[i,j] &lt;- 0 } } } return(hotnet) } Hotnet &lt;- removeColdEdge(A_normalized,W,0.04) Hotnet &lt;- as.matrix(forceSymmetric(Hotnet,&quot;U&quot;)) colnames(Hotnet) &lt;- position rownames(Hotnet) &lt;- position HotEdges &lt;- melt(Hotnet) %&gt;% rename(Source = Var1, Target = Var2, Weight = value) %&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type, Weight) %&gt;% filter(Weight != 0) %&gt;% select(-Weight) edges.copy &lt;- edges edges.copy &lt;- edges.copy %&gt;% select(Source,Target) colnames(edges.copy) &lt;- c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) # get a list of connected components clu &lt;- components(g) res &lt;- groups(clu) getNumComp &lt;- function(edges,nodes,s){ edges.copy = edges edges.copy = edges.copy%&gt;%select(Source,Target) colnames(edges.copy) = c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) clu &lt;- components(g) res &lt;- groups(clu) count &lt;- 0 for(i in 1:length(res)){ if(length(res[[i]]) &gt;= s){ count &lt;- count+1 } } return(count) } 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) In this section, we illustrate a way to determine the value for \\(\\delta\\). We start with simulating 50 datasets under the null hypothesis where no genetic pathway is related to the disease status by permuting observed disease status in order to preserve possible correlations between occurrences of mutations (Vandin et. al, 2012).Then, for a small value of \\(s\\), where often \\(s \\in \\{3,4,5\\}\\), we choose the first \\(\\delta\\) that gives the largest number of subnetworks of size at least \\(s\\). The value \\(s\\) is chosen such that under the null hypothesis the number of connected components found of size at least s is statistically significant. Given the size of our network, we use \\(s = 3\\). Table 5.1 report the number of connected components of size at least 3 as a function of \\(\\delta\\). \\[\\text{Table 5.1: Number of Components with Size &gt; 3 as a Function of} \\;\\delta\\] According to Vandin (2012), an empirical choice is using the first \\(\\delta\\) that gives the maximum number of connected components of size at least 3, which gives \\(\\delta = 0.02\\) in our case. Since increasing \\(\\delta\\) gives us more conservative criteria, we also consider the following values: \\(1.5\\delta = 0.03, 2\\delta = 0.04, 3\\delta = 0.06, 4\\delta = 0.08\\). In fact, if \\(\\delta_1 &gt;\\delta_2\\), then the connected components of size at least 3 obtained using \\(\\delta_2\\) will be subnetworks of those obtained using \\(\\delta_1\\). We applied the above \\(\\delta\\) values to filter the edges and obtained 5 graphs using the graph presented in Chapter 4. Intuitively, as we raise the value for \\(\\delta\\), there will be more isolated nodes and the size of major component will decrease as it gets decomposed into smaller parts. We expect the the true causal pathways will be among the connected components after applying the Enhanced Influence Model and filtering the edges. Figures 5.1 (a) - (e) shows their corresponding major components, which contained the 4 genetic causal pathways listed in Chapter 4. Nodes are sized by the closeness centrality throughout our analysis. \\[\\text{Figure 5.1(a): Major component of the network of mutated genes when delta = 0.02}\\] \\[\\text{Figure 5.1(b): Major component of the network of mutated genes when delta = 0.03}\\] \\[\\text{Figure 5.1(c): Major component of the network of mutated genes when delta = 0.04}\\] \\[\\text{Figure 5.1(d): Major component of the network of mutated genes when delta = 0.06}\\] \\[\\text{Figure 5.1(e): Major component of the network of mutated genes when delta = 0.0}\\] We found that at \\(\\delta = 0.04\\) and \\(\\delta= 0.06\\), the major component both contains precisely the 12 SNP locations that were part of at least one pathway interaction combination. To determine which one of the two is better, we go back to the four original pathways and evaluate their quality. It seems that the major component more accurately describes the truth when \\(\\delta = 0.04\\), as presented below. \\[\\text{Figure 5.2: Modularity Class Breakdown within the Major Component when delta = 0.04}\\] Figure 5.2 shows after modularity decomposition, our algorithm successfully captures most of the structures of the 4 pre-selected genetic pathways we listed in Chapter 4.2. The pink modularity class corresponds perfectly to the first pathway (X2699, X1320, X520, X2881); out of the 5 nodes classified in the orange modularity class, 4 of them come from the second pathway (X2766, X1237, X2075, X521, X526) and 4 from the third pathway (X526, X2766, X2106, X2075, X1533); the 3 nodes in the green modularity class are 3 of the 5 SNP locations from the fourth pathway (X2699, X521, X2881, X1533, X1627). Note that nodes with high closeness centralities such as X521, X1533, and X2699 happen to be those SNP locations shared by multiple pathways. The fact that the fourth pathway captured by our algorithm appears to be most imperfect one might be explained by the fact that 3 of its components are shared with other pathways. As our algorithm obtains subgraphs by removing edges, we conjecture that shared SNP locations by multiple pathways makes the it hard for the algorithm to make a perfect division between pathways. To confirm our thought, we simulated dataset under a simplied situation where no two pathways share a mutural SNP location and presented the results below. 5.4 Alternative Situation In the previous section, we find that our method is confused about which modularity class a certain node belongs to. We hypothesize that this may be due to that the node makes up more than one combination of pathway interactions. We wonder if the problem will arise when each mutation only contributes to one pathway combination (denoted as Scenario B). If the problem universally happens, we need to analyze its cause. We repeated the process, with a twist in the construction of the original dataset. We simulated a dataset where no two pathways share a SNP location. Random simulation gives the following 4 causal genetic pathways: X2608, X182, X1443, X624, X2422 X2454, X1099, X350, X2548, X883 X31, X2725, X608, X471 X815, X2108, X2494, X2812, X1245 Figure 5.3 shows the full network of SNP locations where at least one mutation occurs where the purple part is the largest connected component. \\[\\text{Figure 5.3: Figure Full Network of Mutated Genes under Scenario B}\\] delta value 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 Num.Components, Size&gt;3 100.30 118.10 50.20 10.50 2.40 2.40 2.40 0.00 0.00 \\[\\text{Table 5.2: Number of Components of Size at Least 3 as a Function of} \\;\\delta \\;\\text{under Scenario B}\\] The empirical choice \\(\\delta&#39; = 0.04\\) gives the first mamimum average number of connected components of size at least 3. Experimenting with \\(\\delta = 1.5\\delta&#39;\\) and \\(\\delta = 2\\delta&#39;\\) shows that \\(\\delta = 2\\delta&#39;=0.08\\) gives a perfect fit. Figure 5.4 shows the filtered network obtained from Figure 5.3 using \\(\\delta = 0.08\\). Observe that there is no single major connected components. However, all four pathways exist as independent connected components that are colored in Figure 5.4. Figure 5.5 shows the the filtered graph for the four components. All 4 pathwaysa re identified, which supplies proof for the validity of our method. \\[\\text{Figure 5.4: Resulted Network using}\\; \\delta=0.08 \\;\\text{under Scenario B}\\] \\[\\text{Figure 5.5: All 4 Pathways Identified under Scenario B}\\] 5.5 Code Below is the code that supports our work in this chapter. disease_status_mat &lt;- matrix(NA,50,500) for(i in 1:50){ disease_status_mat[i,] &lt;- permute(disease_status_vector) } pVal.lst &lt;- list() for(k in 1:50){ res &lt;- c() for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_mat[k,]&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) res &lt;- c(res,summary(model)$coefficient[,4][2]) pVal.lst[[k]] = res } } score.lst = list() for(k in 1:50){ score.lst[[k]] = -2*log(pVal.lst[[k]]) } W.lst = list() for(k in 1:50){ W.lst[[k]] = matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W.lst[[k]][i,j] = min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(score.lst[[k]][i],score.lst[[k]][j]) } } } aveNumComp_s &lt;- function(delta, s=3){ # list of adjacency matrices for HotNet for 50 datasets under the null hypothesis # under the given threshold delta Hotnet.lst = list() for(k in 1:50){ Hotnet.lst[[k]] = removeColdEdge(A_normalized,W.lst[[k]],delta) Hotnet.lst[[k]] = as.matrix(forceSymmetric(Hotnet.lst[[k]],&quot;U&quot;)) } HotEdges.lst = list() for(k in 1:50){ colnames(Hotnet.lst[[k]]) = position rownames(Hotnet.lst[[k]]) = position HotEdges.lst[[k]]= melt(Hotnet.lst[[k]]) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0)%&gt;%select(-Weight) } numComp_s = rep(0,50) for(k in 1:50){ numComp_s[k] = getNumComp(HotEdges.lst[[k]],nodes,s) } return(mean(numComp_s)) } x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=3) x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=2) "],["discussion-and-future-work.html", "Chapter 6 Discussion and Future Work 6.1 What did we achieve? 6.2 Limitations 6.3 Future Work", " Chapter 6 Discussion and Future Work 6.1 What did we achieve? The most exciting part of this project to us is using network science to solve real-life problems. Genetics is such an complex topic and affects every part of who we are. Given how chemistry works in our body, it is hard to imagine that we could accurately quantify how genes interact with each other. But we are excited to learn that with some basic assumptions, one could have some predicting power with mathematical tools, even though we have to leave out many details in our modeling process. The takeaway is that we are able to model how pathway interactions cause diseases and use network science tools to detect such pathways. Our assumption states that diseases/traits can be caused by a combination of mutations at SNP locations, and one mutation may be involved in multiple combinations. This poses an inherent challenge for network analysis: it is hard to classify which modularity class that such mutations should belong to. However, we present that our method perfectly classifies different pathway interactions if one mutation could only exist in one combination. 6.2 Limitations A major limitation, as discussed above, is the adherence to biological facts. It is not feasible to exactly replicate the complex biochemical processes along the DNA sequence, and thus our assumptions bear the risk of not representing the reality. During our analysis, we first pre-determined which combinations of variants along the genome could lead to the disease/trait. However, we do not know the underlying true combinations of pathway interactions in real life. When implementing our algorithm in a more realistic setting, we may have difficulty interpreting the validity of the result. For example, in Chapter 4, we see that our method perfectly detects the combination “X2699, X1320, X520, X2881”, and yields slight discrepancies in other combinations. Thus, it is important to test the algorithm in different settings and better understand how the results may be impacted. In addition, many inputs of our method are chosen relatively arbitrarily based on existing literature. We attempted many different values for variables including total SNP locations and the number of combinations. It is, however, important to note that we could not test all potential values for all variables. We would like to understand changes in our algorithm’s accuracy if we have a larger number of SNP locations or more possible combinations etc. 6.3 Future Work Given the time constraint, many interesting problems and extensions remain to be explored and discussed. Below we list two possible directions to furnish our project: We mentioned earlier is how we can incorporate two disease/traits and their corresponding pathways and check if our method accurately detects both pathways under a different setting of noises. Due to the compressed time, we focus on the network analysis aspect of the problem. However, there may be other tools designed for our setting, which may incorporate work from network science, statistical genetics or computational biology. For example, as any connected component could be a candidate for a causal genetic pathway, using false discovery rates, the statistical significance of the overall findings could be evaluated (Vandin et al., 2012). "],["references.html", "Chapter 7 References", " Chapter 7 References Leiserson, M. D., Eldridge, J. V., Ramachandran, S., &amp; Raphael, B. J. (2013). Network analysis of GWAS data. Current opinion in genetics &amp; development, 23(6), 602-610. https://doi.org/10.1016/j.gde.2013.09.003 Vandin, F., Clay, P., Upfal, E., &amp; Raphael, B. J. (2012). Discovery of mutated subnetworks associated with clinical data in cancer. Pacific Symposium on Biocomputing. Pacific Symposium on Biocomputing, 55-66. Vandin, F., Upfal, E., &amp; Raphael, B. J. (2011). Algorithms for detecting significantly mutated pathways in cancer. Journal of computational biology : a journal of computational molecular cell biology, 18(3), 507-522. https://doi.org/10.1089/cmb.2010.0265 Qi, Y., Suhail, Y., Lin, Y. Y., Boeke, J. D., &amp; Bader, J. S. (2008). Finding friends and enemies in an enemies-only network: a graph diffusion kernel for predicting novel genetic interactions and co-complex membership from yeast genetic interactions. Genome research, 18(12), 1991-2004. https://doi.org/10.1101/gr.077693.108 What Are Single Nucleotide Polymorphisms (SNPs)? (n.d.). Retrieved from https://medlineplus.gov/genetics/understanding/genomicresearch/snp/ "]]
