[["index.html", "MATH 479 Network Science Project Preface", " MATH 479 Network Science Project Zhaoheng Li and Zuofu Huang, Fall 2020 Macalester College Preface Hello! Welcome to our final project of Network Science! This bookdown is a work in progress, and please check back early and often (as much as people do to their Github code). Feel free to contact us if you have any questions! Now that we are in the realm of networks, we feel compelled to motivate our project with an xkcd comic related to networks. Credit to xkcd: https://xkcd.com/350/ "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction We are motivated by existing genetic association studies that find the correlation between certain diseases/traits and genetic variants (SNP mutations). We wonder if network analysis can be utilized in the process of genome-wide association studies. Genome wide association studies (GWAS) is a method for identifying the associations between certain genetic regions called loci and one’s trait. Usually among the traits, we are interested in the disease status. Later, we came across the paper named Network Analysis of GWAS data (Leiserson et. al, 2013), where we first saw the connection made between genetics and network science. This motivates our attempt of finding genetic pathway interactions for a certain disease/trait. Intuitively, we would like to think of the simplified scenario: a certain disease can be caused by several genetic pathways. Suppose we have \\(n\\) SNP locations previously identified as related to the disease, and \\(k\\) subsets among the SNP locations that in combination cause the disease (\\(k &lt; n\\)). Our goal is to simulate data that aligns with the proposed setting, and use network science tools to identify these pathway interactions (pretending that we did not know the underlying true subsets). This process aims at testing the validity of the network science tool we propose. Looking forward, we would like to test how the tool behaves when the dataset we simulate contains genetic information for two diseases: we wonder if the algorithm is capable of picking up pathway interaction patterns for both diseases. "],["initial-steps.html", "Chapter 2 Initial Steps 2.1 Genetics Background 2.2 Simulate original data 2.3 Sample mutations for patients at SNP locations 2.4 Sample mutations for non-patients at SNP locations 2.5 Variants at non-SNP locations 2.6 Screening 2.7 Marginal Regression 2.8 Discussion", " Chapter 2 Initial Steps Our initial thought was that Genome-Wide Association Studies data is readily available for public access and that we should be able to retrieve the dataset easily. However, it came unexpected that a research proposal from faculty was needed to obtain GWAS data for research purposes. Therefore, we decide to simulate our own GWAS data for the purpose of this research. 2.1 Genetics Background The human genome contains roughly 234,000 exons, 80% of which contain fewer than 200 base pairs in length. However, mutations in these exons contain a majority of mutations that are related to diseases. Our setting is structured in this context. Suppose we have a disease. It is reasonable to assume that we know where the mutations related to this disease approximately are along the genome. We guess that 1000 loci (specific position where a gene is located) could harbor the disease-related mutations. In addition, we assume that each locus on average contains 200 base pairs (a pair of complementary bases in a double-stranded DNA: A-T, G-C), which corresponds to locus_length &lt;- 200 in the code. loci &lt;- 1000 locus_length &lt;- 200 2.2 Simulate original data We start by creating the dataset. Everyone row is set to the reference level first (i.e. there is no variant). Suppose initially we have 500 individuals, and we categorize 100 as people who have the disease. n &lt;- 500 n_disease &lt;- 100 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = loci*locus_length, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = loci * locus_length,byrow = TRUE)) SNP_location &lt;- sample(1:(loci*locus_length), size = 50, replace = FALSE) reference_level_SNP_location &lt;- reference[SNP_location] 2.3 Sample mutations for patients at SNP locations We then sample mutations at SNP locations who were categorized at patients. disease_people_row_number &lt;- sample(1:500, 100, replace = FALSE) combo_number &lt;- 15 SNP_number &lt;- sample(1:6, combo_number, replace = TRUE) disease_combo &lt;- list() for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) #helper functions for decomposition. helper2 &lt;- function(char){ other_set &lt;- setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;G&quot;,&quot;C&quot;),char) return(sample(other_set,1)) } helper3 &lt;- function(char, p = 0.15){ random &lt;- runif(1) if (random &lt;= (1-3*p)){ return(char) } else if (random &lt;= 1-2*p){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[1]) } else if (random &lt;= (1-p)){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[2]) } else { return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[3]) } } # For patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper2(reference_level_SNP_location[index[j]]) } # non-disease-related SNP mutations non_forced_index &lt;- setdiff(1:50, index) for (k in 1:length(non_forced_index)){ reference_level_SNP_location_copy[non_forced_index[k]] &lt;- helper3(reference_level_SNP_location[non_forced_index[k]],0.15) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy } 2.4 Sample mutations for non-patients at SNP locations We then hypothesize that given a common condition, non-patients are also more likely to have mutations at the SNP locations than at most other locations (e.g. those locations that make human human). # For those who are not set to have disease first (400) # Loop over 50 genes, each one has some possibility to mutate. (More likely than the other nucleotides on the genome) non_disease_row_number &lt;- setdiff(1:500,disease_people_row_number) for (i in non_disease_row_number){ for (j in SNP_location) data[i,j] &lt;- helper3(data[i,j],0.05) } 2.5 Variants at non-SNP locations The next step is simulating random noise at non-SNP locations to better mimic properties of gene mutations in real life. potential_SNP_places &lt;- SNP_location potential_random_change_sites &lt;- setdiff(1:(loci*locus_length),SNP_location) for (i in 1:n){ random_locus &lt;- sample(potential_random_change_sites, size = (loci*locus_length/1000), replace = FALSE) # definitely change for(j in random_locus){ data[i,j] &lt;- helper2(data[i,j]) potential_SNP_places &lt;- c(potential_SNP_places, random_locus) } } potential_SNP_places &lt;- unique(potential_SNP_places) 2.6 Screening With the mutations that non-patients had at SNP locations, some of the 400 people may fall into the “disease” status. We then performed a round of screening for 400 people who were initially categorized without the disease. Surprisingly, we found that a large number of people fall into the “disease” status. We were surprised for two reasons: The probability of mutations at each location is low. Even if many mutations happen for someone, a right “combination of pathways” is needed to achieve the “disease” status, which happens more often than estimated. # Do a round of screening for 400 people who did not initially have the disease NewPatient &lt;- c() for (i in non_disease_row_number){ MutatedSNP &lt;- c() for(j in SNP_location){ if(isMutated(i,j)){ MutatedSNP &lt;- c(MutatedSNP,j) } } for(k in 1:15){ if(all(disease_combo[[k]] %in% MutatedSNP)){ causalPathway &lt;- c() for(position in disease_combo[[k]]){ causalPathway = c(causalPathway,helper2(reference[position])) } if(all(data[i,position] == causalPathway)){ NewPatient &lt;- c(NewPatient,i) break } } } } disease_row_final &lt;- c(disease_people_row_number, NewPatient) disease_status_vector &lt;- rep(FALSE, 500) for (i in 1:500){ if (i %in% disease_row_final){ disease_status_vector[i] &lt;- TRUE } } 2.7 Marginal Regression Once we have simulated potential variants for everyone at every location, we find all places that at least one person has a variation at, select the places and fit a marginal regression at each location against the disease status. for (i in potential_SNP_places){ reference_level_here &lt;- reference[i] for (j in 1:n){ if (data[j,i] == reference_level_here){ data[j,i] &lt;- TRUE } else { data[j,i] &lt;- FALSE } } } subdata &lt;- data[,potential_SNP_places] isMutated &lt;- function(person,position){ if(data[person,position] == reference[position] ){ return(FALSE) } else{ return(TRUE) } } for (i in potential_SNP_places){ summary(lm(disease_status_vector ~ data[,i])) } 2.8 Discussion Problems with this approach, as we realized later, were that: We assumed genetic variants were the only reason people caused the disease, which was almost never the case. People who were initially categorized as non-patients and later changed their status are more than we expected. This casts doubt on the necessity of pre-determining the number of patients (100 in this case). Our approach was not fully supported by pre-existing literature. We pasted pieces of several literature into this approach. The probability of mutations at each location was also not documented. When we are simulating random variants, we set the number of changes to be size = (loci*locus_length/1000) as we believed the average probability of SNP is 1/1000. However, this is faulty because the size was fixed at the expected value of the number of mutation sites, without allowing any difference across individuals. Let \\(\\text{X = number of variants}\\) and \\(\\text{n = number of locations}\\). \\(X\\) follows the distribution: \\(X \\sim Bin(n,p)\\). However, \\(X\\) can vary as we draw from the Binomial distribution. With the reasons above, we keep digging into the literature and tested potential alternatives. "],["progress-and-revision.html", "Chapter 3 Progress and Revision 3.1 Rationale 3.2 Updated Code", " Chapter 3 Progress and Revision 3.1 Rationale When we found out that only SNP locations can be categorized as significant and other loci are exclusively “non-significant”, we realized that we are getting too far into simulation. Although it seemed that every step we take is justified, the simulated data seem unrealistic and overfitting for our scenario. As we were conduting a more extensive literature review process in the hope of shedding light on our next simulation steps, we came across the paper Discovery of Mutated Subnetworks Associated with Clinical Data in Cancer (Vandin et. al, 2012). Section 3.1 of the paper contains a description of how the data is simulated in a slightly different setting. There are a few notable changes that we implemented in the Progress and Revision section. We argue that a common disease can be caused by both genetic variants and external environmental factors, as opposed to the genetic variations alone in our previous simulations. Therefore, we can pre-determine the number of people whose diseases are caused by genetic factors (as the paper suggested, 20% of people who carry the disease). The value of \\(p\\) is determined by the biological background that on average the probability of having a mutation at each location is \\(1/1000\\), as described in “What Are Single Nucleotide Polymorphisms (SNPs)?” (n.d.). For people whose diseases are caused by genetic factors: the probability of mutations at every other location (including SNP locations that were not in their combination) has a probability of \\(p = 1/1000\\). For people whose diseases are caused by non-genetic factors: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For people who do not have the disease: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For the purpose of the simulation, we combine the group of people whose disease are caused by non-genetic factors and the group of people who do not carry the disease. Suppose we have a total of 500 people, half of which do not carry the disease. Then the total number of people whose disease are caused by genetic factors is 10% of the total population, as seen in n_disease &lt;- 0.1n in the Update Code section below. We determine that there are 4 combinations of genetic pathways that cause the disease (which is much more realistic than 15 pathways). Each of the pathway contains a random group of 4-5 variants chosen from 15 SNP locations. The variant could be present in more than one pathway or none of the pathways. We replace the multiplication of loci and locus_length with a total positions of 3000. We argue that reducing the number of loci at first does not change our inference process. As we test the validity of the approach, we then have the freedom of increasing the dimension (column) of the dataset or incorporating another disease/trait and the corresponding genetic pathways in our analysis. 3.2 Updated Code n &lt;- 500 n_disease &lt;- n*0.1 total_position &lt;- 3000 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = total_position, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = total_position,byrow=TRUE)) disease_people_row_number &lt;-seq(1,n_disease) non_disease &lt;- seq((n_disease+1),n) combo_number &lt;- 4 disease_combo &lt;- list() SNP_number &lt;- sample(4:5, combo_number, replace = TRUE) SNP_location &lt;- sample(1:total_position, 15, replace = FALSE) for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } reference_level_SNP_location &lt;- reference[SNP_location] disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) helper &lt;- function(char){ return(sample(setdiff(c(&quot;A&quot;,&quot;C&quot;,&quot;T&quot;,&quot;G&quot;),char),1)) } # function to mutate positions not in the identified pathways mutater &lt;- function(vec,non_position){ mutated &lt;- c() for (i in 1:length(vec)){ if (! i %in% non_position){ rand &lt;- runif(1) if (rand &lt;= 10^{-3}){ vec[i] &lt;- helper(vec[i]) mutated &lt;- c(mutated, i) } } } return(list(vec,mutated)) } # all mutated positions mutated_position &lt;- SNP_location # keep track of mutated positions for each subject # to record co-occurrence frequency of mutations # For causal-pathway-related patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper(reference_level_SNP_location[index[j]]) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy # random change mutated_result &lt;- mutater(data[i,],thiscombo) data[i,] &lt;- mutated_result[[1]] # update the list of all positions that mutated mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } # for everyone else for (k in (n_disease+1):n){ # update mutated positions mutated_result &lt;- mutater(data[k,], SNP_location) data[k,] &lt;- mutated_result[[1]] mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } mutated_position &lt;- unique(mutated_position) # Delete the locations among the 15 pre-identified locations that are not selected to be part of a causal pathway del &lt;- c() for(p in mutated_position){ count &lt;- 0 if(all(data[,p]==reference[p])){ del &lt;- c(del,p) } } mutated_position &lt;- setdiff(mutated_position,del) # Create a subset of the data for all positions with at least one mutation for(position in mutated_position){ # return true if a mutation happens at the position data[,position] &lt;- !(data[,position]==reference[position]) } sub_data &lt;- data[,mutated_position] position &lt;- colnames(sub_data) Create the adjacency matrix A that contains all positions where there is at least one mutation across all subjects. A = matrix(0,length(mutated_position),length(mutated_position)) rownames(A) = colnames(sub_data) colnames(A) = colnames(sub_data) for(i in 1:nrow(sub_data)){ count = sum(sub_data[i,]==TRUE) if(count&gt;=2){ loc = which(as.logical(as.vector(sub_data[i,])),TRUE) pairs_mat = combn(loc,2) for(j in 1:ncol(pairs_mat)){ r = pairs_mat[1,j] c = pairs_mat[2,j] A[r,c] = A[r,c]+1 } } } A &lt;- as.matrix(forceSymmetric(A,&quot;U&quot;)) Calculate the degree of the adjacency matrix. We can understand more of the matrix by calculating the average degree. deg &lt;- rowSums(A) deg ## X636 X1303 X178 X834 X1173 X1320 X2683 X2427 X768 X614 X143 X743 X1255 ## 163 96 146 196 79 146 175 179 167 100 9 8 8 ## X1517 X2615 X1056 X1672 X2478 X2606 X402 X1532 X109 X378 X1156 X1219 X2950 ## 8 8 7 7 7 20 11 8 9 12 12 12 9 ## X2996 X282 X1012 X1025 X2270 X139 X286 X2939 X661 X673 X1414 X2934 X288 ## 16 7 7 7 9 6 6 6 10 7 7 7 8 ## X747 X1344 X1419 X2671 X672 X2590 X1697 X1575 X2063 X2640 X766 X1260 X1416 ## 13 8 13 8 5 16 4 7 10 10 8 5 7 ## X2342 X2796 X620 X1622 X2561 X2894 X202 X1407 X1573 X2516 X371 X505 X1089 ## 7 18 9 19 10 9 7 17 7 7 9 9 9 ## X1741 X2753 X1283 X1518 X220 X316 X2137 X349 X431 X2037 X2887 X46 X781 ## 14 9 5 7 6 9 12 7 7 12 7 8 8 ## X1288 X2081 X2593 X1079 X1708 X2649 X26 X1026 X1809 X1968 X1341 X2076 X1237 ## 8 8 15 6 14 6 20 7 7 7 6 6 5 ## X2175 X1992 X2780 X1097 X1966 X1988 X2421 X2563 X310 X1837 X2407 X70 X1154 ## 16 5 5 8 8 8 8 8 14 11 6 7 9 ## X1296 X2118 X307 X1324 X1942 X2979 X736 X1024 X2433 X575 X1137 X2678 X2930 ## 7 20 10 7 7 7 6 6 6 18 7 14 7 ## X451 X538 X1646 X1817 X1911 X309 X908 X1476 X2304 X494 X500 X1256 X2252 ## 11 11 8 8 5 11 8 13 11 11 7 7 7 ## X61 X543 X647 X899 X168 X1900 X2002 X175 X227 X264 X1943 X2453 X1187 ## 7 7 7 7 18 8 8 9 22 9 9 9 8 ## X1759 X1924 X2209 X423 X1973 X2261 X2851 X1213 X1895 X323 X1629 X1643 X1784 ## 8 8 10 6 10 4 4 6 6 13 13 13 13 ## X1851 X2436 X2464 X2808 X344 X681 X1662 X1710 X2597 X2665 X83 X453 X489 ## 13 13 13 17 9 9 9 9 9 9 9 9 9 ## X1196 X2100 X41 X247 X1443 X1776 X2302 X2883 X115 X342 X1209 X2539 X967 ## 9 16 14 12 9 11 9 17 8 7 7 7 7 ## X1128 X1203 X2157 X107 X1273 X1564 X2585 X2685 X420 X725 X1271 X1319 X1421 ## 3 3 3 9 6 8 4 4 10 10 10 10 10 ## X1447 X1654 X1789 X2497 X2783 X104 X839 X1904 X2316 X2546 X942 X1172 X814 ## 16 15 10 14 10 4 4 7 4 8 1 5 0 ## X1001 X1201 X1034 X1556 X2533 X2922 X579 X2059 X2681 X2720 X7 X2173 X2398 ## 6 6 3 3 3 3 12 4 4 9 6 3 6 ## X1050 X2017 X403 X848 X897 X1174 X2856 X2946 X2852 X2929 X919 X2914 X891 ## 2 2 5 5 5 5 5 5 10 3 1 1 3 ## X1232 X1798 X2341 X235 X1598 X341 X1286 X1512 X2725 X1455 X2205 X2377 X2503 ## 3 3 3 1 1 2 2 2 1 7 8 5 5 ## X2595 X2824 X2476 X1420 X2412 X1179 X1207 X2882 X611 X1916 X1984 X317 X444 ## 12 5 4 1 9 2 4 2 2 2 4 7 7 ## X1017 X1155 X2129 X2214 X2380 X303 X562 X2442 X2836 X449 X1887 X370 X2821 ## 7 10 13 7 7 6 6 3 3 2 6 10 1 ## X836 X1969 X2036 X141 X508 X345 X287 X700 X1168 X2033 X2423 X598 X1974 ## 2 2 7 1 1 0 2 2 2 1 6 0 11 ## X2470 X2844 X521 X832 X1116 X1182 X2829 X374 X2657 X954 X1442 X318 X2024 ## 2 2 7 4 4 4 4 1 2 3 5 4 15 ## X2165 X2479 X1311 X1665 X2963 X1057 X1619 X2435 X146 X1015 X56 X1305 X1485 ## 4 4 4 2 2 1 5 2 2 2 0 2 6 ## X2664 X1208 X1509 X1376 X1449 X2555 X2752 X2771 X238 X2727 X2758 X1143 X2957 ## 2 7 2 4 4 4 4 4 2 7 2 1 1 ## X137 X2543 X273 X1897 X2364 X353 X1197 X1323 X2619 X1679 X2084 X9 X993 ## 1 4 2 7 9 4 3 4 3 1 0 1 1 ## X644 X1169 X1448 X2098 X1014 X1152 X443 X895 X1338 X1424 X1888 X2626 X2876 ## 3 3 3 6 3 1 9 6 6 6 13 6 6 ## X47 X32 X1005 X1606 X1760 X25 X1171 X1460 X2995 X1935 X2265 X2680 X2791 ## 0 3 3 3 3 9 4 4 9 4 4 4 4 ## X870 X1194 X501 X2153 X738 X2251 X240 X653 X1099 X2738 X2901 X842 X1639 ## 2 0 4 10 2 1 5 3 5 3 0 3 5 ## X1664 X2730 X72 X827 X1527 X1581 X1593 X2448 X2800 X60 X635 X677 X2404 ## 3 6 6 6 8 6 7 6 6 3 1 2 5 ## X35 X37 X116 X1362 X1822 X2845 X605 X2103 X1465 X2201 X2719 X416 X1062 ## 5 5 5 8 5 8 5 1 3 3 7 3 3 ## X1820 X2568 X1841 X2357 X2461 X664 X902 X1149 X1864 X2977 X1160 X2697 X779 ## 3 8 7 5 6 1 1 2 5 2 1 3 2 ## X892 X2756 X419 X487 X1711 X272 X780 X2200 X2348 X84 X686 X1879 X2898 ## 2 4 2 2 2 8 4 8 4 8 3 3 3 ## X296 X351 X409 X454 X876 X1756 X2170 X2865 X245 X567 X2172 X590 X1589 ## 7 12 10 7 7 7 7 7 2 2 2 2 2 ## X2548 X2318 X1797 X2635 X197 X1293 X465 X532 X101 X1046 X1698 X2430 X2716 ## 5 0 1 1 12 3 1 1 7 9 11 7 7 ## X2755 X77 X1250 X1791 X2296 X2604 X15 X2320 X2831 X882 X1252 X1703 X2367 ## 15 13 4 4 4 9 2 2 2 4 4 4 8 ## X2512 X2693 X2809 X1854 X2385 X210 X315 X907 X1150 X2116 X2130 X2617 X2051 ## 4 4 6 3 6 10 11 8 8 12 8 10 0 ## X599 X2871 X1534 X1693 X10 X66 X224 X1342 X1496 X2222 X963 X1241 X1387 ## 9 1 1 1 5 5 5 5 5 5 7 2 2 ## X393 X492 X249 X1827 X2074 X2399 X2193 X211 X2199 X1198 X1926 X106 X663 ## 1 1 4 4 4 4 0 1 1 4 0 3 3 ## X1549 X2007 X1482 X1651 X313 X34 X1123 X1507 X2869 X250 X628 X1363 X1979 ## 3 3 1 1 0 5 3 3 5 1 4 4 11 ## X2792 X2811 X43 X486 X1506 X2378 X68 X1107 X2878 X871 X1596 X2542 X55 ## 4 4 2 2 2 3 4 4 4 2 2 11 5 ## X1400 X2072 X2091 X2468 X1896 X2392 X2530 X826 X878 X74 X935 X1345 X2411 ## 1 1 1 3 2 2 2 1 10 3 3 8 3 ## X40 X511 X600 X1368 X2858 X1355 X2132 X2658 X2973 X1533 X2376 X2594 X442 ## 4 4 4 4 7 3 3 3 3 2 2 2 2 ## X497 X2618 X813 X1389 X1063 X1330 X1751 X2249 X2675 X2782 X328 X1481 X2710 ## 4 2 8 3 3 3 7 3 2 5 2 10 2 ## X6 X1054 X702 X1125 X1456 X1614 X1257 X1438 X1648 X1925 X721 X1609 X2330 ## 0 2 3 8 3 3 3 3 3 3 2 2 2 ## X1167 X1430 X1395 X2139 X2884 X2932 X167 X1510 X1956 X815 X1371 X1645 X1764 ## 1 3 2 2 5 1 3 3 3 2 14 10 5 ## X2297 X2547 X2241 X996 X1106 X2389 X85 X92 X988 X1466 X1742 X2225 X2331 ## 9 5 1 6 2 2 8 15 8 12 8 8 8 ## X2498 X510 X763 X2026 X1825 X2441 X564 X2759 X2842 X1625 X2117 X1735 X2763 ## 9 5 2 0 5 6 2 4 1 2 2 1 3 ## X98 X1115 X1989 X2581 X150 X469 X2772 X2917 X846 X1243 X683 X1899 X1462 ## 3 3 3 7 0 3 9 3 1 1 2 2 2 ## X1826 X2496 X1314 X1779 X2401 X1315 X1810 X94 X2962 X470 X1215 X1561 X1574 ## 2 2 2 2 7 2 2 1 1 4 4 6 4 ## X1845 X51 X2141 X1270 X2588 X557 X1637 X573 X2167 X2361 X266 X2127 X2896 ## 4 4 4 1 1 2 5 3 3 3 2 2 2 ## X758 X2499 X729 X1120 X2737 X401 X1310 X601 X1814 X1875 X2279 X2390 X2814 ## 1 1 2 2 2 7 3 8 7 12 7 7 14 ## X621 X773 X1666 X1824 X2631 X185 X1003 X518 X589 X2079 X2446 X1060 X1445 ## 5 5 9 5 5 2 2 3 3 3 3 5 6 ## X1691 X2230 X2269 X132 X2027 X2888 X1457 X1930 X2070 X2960 X1068 X634 X2011 ## 8 5 5 2 6 2 4 4 8 4 2 3 3 ## X2886 X1450 X2733 X680 X879 X2739 X749 X1059 X1186 X1692 X2890 X57 X685 ## 3 3 3 1 5 5 6 6 6 9 6 4 4 ## X968 X1928 X1952 X2473 X117 X764 X1954 X642 X1030 X1871 X2259 X607 X1808 ## 5 4 3 6 2 12 2 9 5 7 5 2 4 ## X1964 X2190 X2426 X2801 X230 X717 X793 X1739 X135 X1958 X491 X948 X1312 ## 4 4 4 4 3 4 3 3 1 1 3 3 3 ## X1444 X221 X2114 X2451 X2480 X757 X189 X2785 X1413 X2406 X389 X1158 X1189 ## 3 0 2 5 2 0 0 2 2 7 5 5 5 ## X2219 X705 X1347 X2853 X645 X946 X1786 X476 X2768 X1565 X2921 X267 X604 ## 5 2 4 2 3 3 3 2 2 4 11 3 3 ## X762 X1423 X1963 X2494 X1058 X2012 X2254 X2959 X578 X1246 X1634 X2418 X789 ## 3 3 1 6 3 3 3 1 3 3 3 3 5 ## X2724 X280 X648 X1109 X2233 X558 X2069 X2740 X2770 X1240 X1425 X2460 X2964 ## 5 3 3 3 3 4 4 4 4 1 5 1 1 ## X861 X980 X1985 X2528 X380 X1933 X2731 X2832 X256 X1505 X1610 X1804 X2672 ## 0 4 7 6 5 5 5 8 6 6 7 6 6 ## X2774 X429 X1337 X1520 X1594 X2767 X2936 X630 X1584 X2822 X1477 X395 X531 ## 6 1 4 2 4 4 4 8 3 6 0 2 9 ## X1938 X458 X950 X1021 X81 X1042 X1140 X1688 X1073 X1074 X641 X1768 X2106 ## 4 2 2 4 5 6 5 7 2 2 5 5 5 ## X2849 X30 X231 X1300 X1503 X2835 X509 X845 X1010 X2408 X1307 X1677 X2777 ## 5 1 4 8 4 4 5 5 8 3 2 2 6 ## X2827 X624 X1987 X193 X606 X561 X1621 X1839 X2472 X435 X1668 X2071 X2239 ## 2 1 1 4 10 3 3 3 3 10 3 3 3 ## X5 X883 X2186 X1276 X2163 X2280 X874 X2088 X1707 X343 X1163 X2038 X2862 ## 3 3 3 2 1 1 3 3 4 3 3 2 2 ## X233 X1230 X1418 X699 X1548 X2402 X886 X716 X1399 X2889 X1181 X2326 X424 ## 3 2 2 3 3 3 1 4 4 4 5 8 7 ## X1346 X1592 X147 X350 X1569 X1780 X2044 X2236 X2425 X257 X2663 X2605 X2109 ## 3 3 2 2 5 5 5 5 5 1 1 3 1 ## X379 X806 X1121 X2956 X331 X788 X2197 X1541 X2257 X2534 X1410 X1431 X658 ## 4 9 4 7 4 4 9 2 2 2 2 2 4 ## X889 X1525 X276 X1280 X284 X2490 X2933 X21 X171 X1239 X1359 X1746 X1765 ## 4 4 2 2 3 3 3 3 3 3 5 5 5 ## X2181 X2235 X1960 X1185 X1802 X2140 X655 X739 X2951 X334 X969 X460 X737 ## 5 5 0 2 2 7 5 5 5 3 3 9 4 ## X1572 X1657 X1722 X157 X651 X1267 X2055 X2136 X2300 X2144 X2345 X1092 X1114 ## 5 4 11 7 13 7 7 7 7 1 1 4 1 ## X187 X436 X480 X894 X1673 X1847 X1522 X252 X1190 X1329 X2207 X523 X2621 ## 7 7 7 7 7 7 0 5 5 5 8 1 1 ## X234 X1842 X2510 X847 X1087 X2713 X1238 X2090 X2133 X718 X1733 X2005 X2351 ## 6 4 4 2 2 2 0 2 1 3 3 3 3 ## X617 X2187 X1009 X69 X751 X366 X1071 X1777 X332 X2171 X1133 X2911 X612 ## 7 2 1 3 8 5 5 5 2 5 4 1 2 ## X2112 X2227 X386 X1582 X2180 X2747 X1644 X204 X615 X1997 X2974 X2840 X504 ## 2 2 4 4 4 4 1 5 11 2 2 1 1 ## X772 X1136 X2110 X367 X2998 X215 X1038 X2048 X65 X1077 X2857 X818 X1069 ## 1 1 1 2 2 3 7 3 2 2 2 2 3 ## X2633 X1110 X1861 X2492 X2525 X396 X1626 X181 X785 X1411 X1358 X1690 X1944 ## 2 4 4 4 2 1 1 3 3 3 3 3 3 ## X760 X1388 X1901 X463 X1184 X2189 X2253 X2147 X2670 X2843 X966 X1104 X1878 ## 2 2 2 4 4 4 4 3 3 3 5 5 5 ## X514 X1141 X1704 X2242 X52 X265 X2358 X910 X629 X2288 X205 X472 X2699 ## 6 6 6 6 2 2 2 0 2 4 4 4 9 ## X524 X347 X750 X212 X356 X299 X2061 X865 X207 X1028 X2668 X1922 X2034 ## 0 6 3 2 2 1 1 0 2 2 2 1 3 ## X930 X2456 X1907 X2324 X123 X333 X1304 X1972 X1647 X795 X2030 X2303 X369 ## 1 1 2 2 1 1 1 1 2 2 2 2 2 ## X2554 X586 X833 X1583 X1998 X2391 X616 X1277 X920 X1364 X2360 X2825 X1427 ## 2 7 7 7 7 7 5 5 3 3 3 3 5 ## X2474 X2507 X2751 X2958 X2847 X2403 X2694 X2206 X91 X1378 X1402 X860 X1142 ## 5 5 5 5 2 3 3 2 2 2 4 5 2 ## X1951 X188 X2443 X1291 X2644 X549 X2764 X1539 X1131 X1493 X2517 X722 X1734 ## 2 2 2 1 1 3 3 1 2 2 7 4 4 ## X2311 X2447 X1661 X608 X321 X1090 X2065 X455 X1587 X2092 X2577 X1086 X2695 ## 4 7 1 1 0 1 1 3 3 3 0 1 1 ## X2793 X162 X1638 X2458 X2703 X196 X2484 X54 X1615 X2272 X2085 X1994 X2317 ## 2 4 4 4 4 2 2 2 2 2 2 2 2 ## X2047 X2444 X400 X975 X368 X2195 X2350 X209 X2328 X971 X923 X1715 X1580 ## 5 5 1 1 2 2 2 1 1 0 2 2 1 ## X1796 X2893 X2192 X2058 X86 X134 X2943 X67 X79 X360 X921 X1882 X2989 ## 2 2 2 0 3 3 3 2 2 2 2 2 2 ## X254 X928 X1853 X2149 X411 X759 X1799 X1815 X2053 X2538 X279 X2701 X994 ## 4 4 4 1 4 4 4 4 4 1 1 1 3 ## X1858 X767 X2138 X2947 X807 X1067 X1816 X1829 X1398 X89 X1292 X2569 X2573 ## 3 3 3 7 3 3 2 2 1 5 5 5 5 ## X355 X528 X2592 X1754 X1856 X2509 X2646 X581 X473 X657 X394 X2294 X597 ## 2 2 2 4 4 4 4 1 1 1 1 1 2 ## X2580 X2828 X782 X1909 X2050 X709 X1126 X1701 X2610 X375 X1578 X1088 X2652 ## 2 0 5 5 5 3 3 4 4 4 4 4 4 ## X853 X2386 X140 X512 X1790 X1835 X42 X812 X1247 X493 X1151 X1259 ## 2 2 3 3 3 3 3 3 3 2 2 2 "],["network-construction.html", "Chapter 4 Network Construction 4.1 Network Construction Process 4.2 Analysis 4.3 Centrality Measures Report 4.4 Preliminary Conclusions", " Chapter 4 Network Construction 4.1 Network Construction Process Below are the steps for calculating the “gene score” of each location that quantifies the degree of association between a base position and the disease/trait of interest. A higher score means a stronger association. For each position \\(g\\), we performed marginal regression and obtain a p-value, \\(p_g\\). Every position then is assigned a score \\(\\sigma(g) = -2log(p_g)\\) (Vandin et al., 2012). Two positions share an edge if they occur together, and the edge weight is their co-occurrence number. # record p values for each position mutations_pVal = c() disease_status_vector = c(rep(1,n/2),rep(0,n/2)) # Arbitrarily assign the first half with disease for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_vector&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) mutations_pVal = c(mutations_pVal,summary(model)$coefficient[,4][2]) } # compute score for each mutated position mutations_score &lt;- -2*log(mutations_pVal) edges = melt(A) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;%mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type, Weight) %&gt;% filter(Weight != 0) nodes = as.data.frame(colnames(sub_data))%&gt;%mutate(Lable= colnames(sub_data)) colnames(nodes) = c(&quot;Id&quot;,&quot;Lable&quot;) A.dat = as.data.frame(A) 4.2 Analysis After revising our simulation methodology, we simulated using 3000 base positions and 500 samples to obtain the following graphs. 12 of the 15 previously identified SNP locations are chosen to be part of at least one genetic pathway: X520, X521, X526, X1237, X1320, X1533, X1627, X2075, X2106, X2699, X2766, and X2881. These 12 effective SNP locations form 4 causal pathways that lead to the disease: X2699, X1320, X520, X2881 X2766, X1237, X2075, X521, X526 X526, X2766, X2106, X2075, X1533 X2699, X521, X2881, X1533, X1627 After a round of random mutations, we obtain 1187 mutated positions in total. This gives us an undirected weighted graph with 1187 nodes and 2838 edges, which produces an average degree of4.78. There is a single major component containing roughly 65% of its nodes. Expectedly, all causal pathways identified beforehand exist within this major connected component. Figure 4.1 shows the full graph, while Figure 4.2 shows its single major component. Using a resolution of 1, we obtained 25 modularity classes within the major connected component. The 12 selected positions are divided between two largest modules. \\[\\text{Figure} \\; 4.1 :\\; \\text{Full Network of Mutated Gene Base Positions}\\] \\[\\text{Figure} \\; 4.2 :\\; \\text {Modularity Class Decomposition within the Major Connected Component, with Nodes Sized According to Closeness Centrality}\\] 4.3 Centrality Measures Report Table 4.1 reports the top 12 nodes ranked by their degrees, eigenvector centrality, closeness centrality and betweeness centrality. The 12 effective disease-related positions selected are exactly the top 12 nodes with the greatest degrees and eigenvector centrality. This might be a result of the high degree of inter-connectivity among these positions. As a comparison, the \\(8^{th}\\), \\(10^{th}\\), and \\(12^{th}\\) nodes with the highest closeness centrality are random variations, while 8 of the top 12 nodes with the greatest betweenness centrality are random variations. Nodes colored blue below are random variables; nodes colored in red are nodes representing 12 SNP locations, where each is part of at least one combination. Rank Degree Eigenvector Centrality Closeness Centrality Betweeness Centrality 1 X2699 X2881 X2881 X2881 2 X2881 X2699 X2699 X2699 3 X521 X521 X1533 X1533 4 X2075 X1533 X520 X807 5 X2766 X2075 X1320 X2083 6 X526 X2766 X521 X2438 7 X1533 X526 X2075 X2251 8 X520 X520 X2766 X1301 9 X1320 X1320 X526 X1806 10 X1237 X1627 X39 X1739 11 X1627 X1237 X1627 X521 12 X2106 X2106 X1889 X571 \\[\\text{Figure 4.1: Top 12 nodes with the highest degree, eigenvector centrality, closeness centrality and betweenness centrality}\\] 4.4 Preliminary Conclusions In this chapter, we found the exact 12 SNP locations that make up variant combinations. Network Science is powerful! Here comes the question: Why don’t we simply use degree centrality and eigenvector centrality to detect the SNP locations then? Why don’t we stop here? There are three reasons: Our goal is to not only find which mutations cause diseases, but also which combinations cause diseases. The centrality measures we have do not allow us to infer the structure of the subnetwork of 12 nodes. Our simulation uses co-occurrence counts to build edges, while in reality there could be more intrinsic ways to determine edges between SNPs. We choose the top 12 nodes for centrality measures because we know the underlying truth that there should be 12 SNP locations from our simulation. It is difficult to find a cutoff without knowing the exact number of SNP locations involved, provided that a distinguishable gap in centrality measures (in this case, between 12th and 13th) does not exist. "],["enhanced-influence-model.html", "Chapter 5 Enhanced Influence Model 5.1 Graph Diffusion Kernel 5.2 Enhanced Influence Model 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) 5.4 Alternative Situation 5.5 Code", " Chapter 5 Enhanced Influence Model After constructing a network using our simulated data, we moved on to use the Enhanced Influence Model to identify significant subnetworks within the graph that shed light on genetic causal pathways. We will first introduce the graph diffusion kernel as the first step to measure the extent of mutual interaction between genes in our network. 5.1 Graph Diffusion Kernel Here we imagine that the importance of nodes flows along edges. Initially, query nodes are selected to serve as sources where fluid is pumped in at a constant rate which then diffuses through the network. In addition, we assume that fluid leaks out of each node at a constant rate \\(\\gamma\\). Intuitively, large \\(\\gamma\\) means faster rate of loss and therefore shorter diffusive paths. Essentially, the paths reflects diffusion of random walkers from a source. At equilibrium, there is no net flow in the entire network. The more interaction a node has with the query nodes, the more fluid it will contain at the equilibrium (Qi et al., 2008). Following the procedure in previous literature (Vandin, Upfal, and Raphael, 2011), we set \\(\\gamma = 5\\), which is approximately the average degree of a node in our network. Mathematically,let \\(u(t)\\) denotes the unit step function where \\[u(t) = \\begin{cases}0 \\;\\text{ if }\\;t&lt;0\\\\1 \\;\\text{ if }\\;t&gt;0 \\end{cases},\\] and \\(b_i = 1\\) if i is the source node of interest while \\(b_i = 0\\) otherwise. The amount of fluid contained by node \\(i\\) at time t is \\(x_i(t)\\) is governed by the flow in and out of it, \\[\\frac{d}{dt}x_i(t) = \\sum_j A_{ij}x_j(t)-\\sum_jA_{ji}x_i(t)-\\gamma x_i(t)\\] As \\(t\\to \\infty\\), the fluid distribution approaches to its equilibrium distribution at which the influence of node \\(i\\) to other nodes is measured by \\[L_\\gamma^{-1}\\vec{b_i}\\] where \\(\\vec{b_i}\\) is the standard basis with 1 at its \\(i^{th}\\) entry. Here, \\(L_\\gamma = S-A+\\gamma I\\) is the shifted graph Laplacian by \\(\\gamma\\) where \\(S\\) is the diagonal matrix whose diagonal entries are the corresponding degrees. In practice, we normalize A symmetrically by \\(S^{-\\frac{1}{2}}AS^{-\\frac{1}{2}}\\) such that the edge weights between two nodes are normalized by the degrees and replace \\(S\\) correspondingly to obtain the Laplacian (Qi et al. 2008). Here, the \\(ij\\) entry of \\(L_\\gamma^{-1}\\) gives the influence of \\(j\\) on \\(i\\), which may or may not equal to the \\(ji\\) entry of \\(L_\\gamma^{-1}\\). To better interpret the result, we define the mutual influence between i and j to be \\(\\tilde{i}(i,j) = \\min(L_\\gamma^{-1}[i,j],L_\\gamma^{-1}[j,i])\\). (Vandin, Upfal, and Raphael, 2011) 5.2 Enhanced Influence Model Enhanced Influence Model is an efficient algorithm to identify a significantly mutated subnetwork with respect to gene interactions by incorporating considerations of both the topology of the network and significance of individual genes with respect to the disease (Vandin, Upfal, and Raphael, 2011). Below are the key procedures involved in the Enhanced Influence Model: Recall from Chapter 4, marginal regression gives a p-value, \\(p_i\\) for each gene \\(i\\). We then assign a score \\(\\sigma_i\\) to a gene \\(i\\) where \\(\\sigma_i = -2\\log(p_i)\\). For each pair of genes (\\(i\\),\\(j\\)), their mutual interaction is measured by \\(w(i,j) = \\max(\\sigma_i,\\sigma_j)*\\tilde{i}(i,j)\\) (Vandin et al., 2011). Next, we remove all edges with weights smaller than a threshold \\(\\delta\\) to obtain a subgraph. In Section 5.3, we shall exhibit a method to determine this cold-edge threshold \\(\\delta\\). The connected components remained are candidates for genetic pathways. The code below shows how we construct the enhanced influence model from scratch. # normalize A A_normalized &lt;- matrix(0,nrow(A),nrow(A)) for(i in 1:(nrow(A)-1)){ for(j in i:nrow(A)){ if(deg[i]!=0 &amp;&amp; deg[j]!=0){ A_normalized[i,j] &lt;- A[i,j]/sqrt(deg[i]*deg[j]) } } } A_normalized &lt;- forceSymmetric(A_normalized,&quot;U&quot;) A_normalized &lt;- as.matrix(A_normalized) # normalize the corresponding degree matrix S S_normalized &lt;- diag(rowSums(A_normalized)) gamma &lt;- 5 L_gamma &lt;- S_normalized+diag(gamma,nrow(A))-A_normalized inv_L_gamma &lt;- solve(L_gamma) # compute symmetric importance score using Enhanced Influence Model W &lt;- matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W[i,j] &lt;- min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(mutations_score[i],mutations_score[j]) } } # helper function to remove cold_edge removeColdEdge &lt;- function(mat,W,delta){ hotnet &lt;- mat for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ if(W[i,j]&lt;delta){ hotnet[i,j] = 0 } } } return(hotnet) } Hotnet &lt;- removeColdEdge(A_normalized,W,0.04) Hotnet &lt;- as.matrix(forceSymmetric(Hotnet,&quot;U&quot;)) colnames(Hotnet) &lt;- position rownames(Hotnet) &lt;- position HotEdges &lt;- melt(Hotnet) %&gt;% rename(Source = Var1, Target = Var2, Weight = value) %&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0) %&gt;% select(-Weight) edges.copy &lt;- edges edges.copy &lt;- edges.copy %&gt;% select(Source,Target) colnames(edges.copy) &lt;- c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) # get a list of connected components clu &lt;- components(g) res &lt;- groups(clu) getNumComp &lt;- function(edges,nodes,s){ edges.copy = edges edges.copy = edges.copy%&gt;%select(Source,Target) colnames(edges.copy) = c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) clu &lt;- components(g) res &lt;- groups(clu) count &lt;- 0 for(i in 1:length(res)){ if(length(res[[i]]) &gt;= s){ count = count+1 } } return(count) } 5.3 Determine Value for Cold-Edge Threshold \\(\\delta\\) In this section, we illustrate a way to determine the value for \\(\\delta\\). We start with simulating 50 datasets under \\(H_0^P\\) by permuting observed disease status. (Vandin et. al, 2012) Then, for a small value of \\(s\\), where often \\(s \\in \\{3,4,5\\}\\), we choose the first \\(\\delta\\) that gives the largest number of subnetworks of size at least \\(s\\). Given the size of our network, we use \\(s = 3\\). Table 5.1 report the number of connected components of size at least 3 as a function of \\(\\delta\\). delta value 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 Num.Components, Size&gt;3 100.30 118.10 50.20 10.50 2.40 2.40 2.40 0.00 0.00 According to Vandin (2012), an empirical choice is using a first \\(\\delta\\) that gives the maximum number of connected components of size at least 3, which gives \\(\\delta = 0.02\\) in our case. Since increasing \\(\\delta\\) gives us more conservative criteria, we also consider the following values: \\(1.5\\delta = 0.03, 2\\delta = 0.04, 3\\delta = 0.06, 4\\delta = 0.08\\). In fact, if \\(\\delta_1 &gt;\\delta_2\\), then the connected components of size at least 3 obtained using \\(\\delta_2\\) will be a subnetwork of those obbtained using \\(\\delta_1\\). For different \\(\\delta\\) values above, we construct graphs for the major component in each network, as shown by Figures 5.1 (a) - (e). In the ideal scenario, we expect that the major component contains and only contains the SNP locations involved in genetic pathways. This is one way that we could use to evaluate our results. Intuitively, as we raise the value for \\(\\delta\\), there will be more isolated nodes and the size of major component will decrease as it gets decomposed into smaller parts. \\[\\text{Figure 5.1(a): Major component of the network of mutated genes when delta = 0.02}\\] \\[\\text{Nodes Sized by Closeness Centrality}\\] \\[\\text{Figure 5.1(b): Major component of the network of mutated genes when delta = 0.03}\\] \\[\\text{Figure 5.1(c): Major component of the network of mutated genes when delta = 0.04}\\] \\[\\text{Figure 5.1(d): Major component of the network of mutated genes when delta = 0.06}\\] \\[\\text{Figure 5.1(e): Major component of the network of mutated genes when delta = 0.0}\\] We found that at \\(\\delta = 0.04\\) and \\(\\delta= 0.06\\), the major component both contains precisely the 12 SNP locations that were part of at least one pathway interaction combination. To determine which one of the two is better, we go back to the four original pathways and evaluate their quality. It seems that the major component more accurately describes the truth when \\(\\delta = 0.04\\), as presented below. \\[\\text{Figure 5.2: Modularity Class Breakdown within the Major Component when delta = 0.04}\\] 5.4 Alternative Situation In the previous section, we find that our method is confused about which modularity class a certain node belongs to. We hypothesize that this may be due to that the node makes up more than one combination of pathway interactions. We wonder if the problem will arise when each mutation only contributes to one pathway combination (denoted as Scenario B). If the problem universally happens, we need to analyze its cause. We repeated the process, with a twist in the construction of the original dataset. The full network of mutated genes looks like this: \\[\\text{Figure 5.3: Figure Full Network of Mutated Genes under Scenario B}\\] The major component in the network is as follows: \\[\\text{Figure 5.4: Modularity Class Breakdown within the Major Component under Scenario B}\\] Our modularity class breakdown exactly replicates the combinations of pathways that cause the disease. This supplies proof for the validity of our method. 5.5 Code Below is the code that supports our work in this chapter. disease_status_mat &lt;- matrix(NA,50,500) for(i in 1:50){ disease_status_mat[i,] &lt;- permute(disease_status_vector) } pVal.lst &lt;- list() for(k in 1:50){ res &lt;- c() for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_mat[k,]&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) res &lt;- c(res,summary(model)$coefficient[,4][2]) pVal.lst[[k]] = res } } score.lst = list() for(k in 1:50){ score.lst[[k]] = -2*log(pVal.lst[[k]]) } W.lst = list() for(k in 1:50){ W.lst[[k]] = matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W.lst[[k]][i,j] = min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(score.lst[[k]][i],score.lst[[k]][j]) } } } aveNumComp_s &lt;- function(delta, s=3){ # list of adjacency matrices for HotNet for 50 datasets under the null hypothesis # under the given threshold delta Hotnet.lst = list() for(k in 1:10){ Hotnet.lst[[k]] = removeColdEdge(A_normalized,W.lst[[k]],delta) Hotnet.lst[[k]] = as.matrix(forceSymmetric(Hotnet.lst[[k]],&quot;U&quot;)) } HotEdges.lst = list() for(k in 1:10){ colnames(Hotnet.lst[[k]]) = position rownames(Hotnet.lst[[k]]) = position HotEdges.lst[[k]]= melt(Hotnet.lst[[k]]) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0)%&gt;%select(-Weight) } numComp_s = rep(0,10) for(k in 1:10){ numComp_s[k] = getNumComp(HotEdges.lst[[k]],nodes,s) } return(mean(numComp_s)) } x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=3) x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=2) "],["discussion-and-future-work.html", "Chapter 6 Discussion and Future Work 6.1 What did we achieve? 6.2 Limitations 6.3 Future Work", " Chapter 6 Discussion and Future Work 6.1 What did we achieve? The most exciting part of this project to us is using network science to solve real-life problems. Genetics is such an complex topic and affects every part of who we are. Given how chemistry works in our body, it is hard to imagine that we could accurately quantify how genes interact with each other. But we are excited to learn that with some basic assumptions, one could have some predicting power with mathematical tools, even though we have to leave out many details in our modeling process. The takeaway is that we are able to model how pathway interactions cause diseases and use network science tools to detect such pathways. Our assumption states that diseases/traits can be caused by a combination of mutations at SNP locations, and one mutation may be involved in multiple combinations. This poses an inherent challenge for network analysis: it is hard to classify which modularity class that such mutations should belong to. However, we present that our method perfectly classifies different pathway interactions if one mutation could only exist in one combination. 6.2 Limitations A major limitation, as discussed above, is the adherence to biological facts. It is not feasible to exactly replicate the complex biochemical processes along the DNA sequence, and thus our assumptions bear the risk of not representing the reality. During our analysis, we first pre-determined which combinations of variants along the genome could lead to the disease/trait. However, we do not know the underlying true combinations of pathway interactions in real life. When implementing our algorithm in a more realistic setting, we may have difficulty interpreting the validity of the result. For example, in Chapter 4, we see that our method perfectly detects the combination “X2699, X1320, X520, X2881”, and yields slight discrepancies in other combinations. Thus, it is important to test the algorithm in different settings and better understand how the results may be impacted. In addition, many inputs of our method are chosen relatively arbitrarily based on existing literature. We attempted many different values for variables including total SNP locations and the number of combinations. It is, however, important to note that we could not test all potential values for all variables. We would like to understand changes in our algorithm’s accuracy if we have a larger number of SNP locations or more possible combinations etc. 6.3 Future Work Given the time constraint, many interesting problems and extensions remain to be explored and discussed. One extension that we mentioned earlier is how we can incorporate two disease/traits and their corresponding pathways and check if our method accurately detects both pathways under a different setting of noises. In addition, there may be other tools designed for our setting, which may incorporate work from network science, statistical genetics or computational biology. "],["references.html", "Chapter 7 References", " Chapter 7 References Leiserson, M. D., Eldridge, J. V., Ramachandran, S., &amp; Raphael, B. J. (2013). Network analysis of GWAS data. Current opinion in genetics &amp; development, 23(6), 602-610. https://doi.org/10.1016/j.gde.2013.09.003 Vandin, F., Clay, P., Upfal, E., &amp; Raphael, B. J. (2012). Discovery of mutated subnetworks associated with clinical data in cancer. Pacific Symposium on Biocomputing. Pacific Symposium on Biocomputing, 55-66. Vandin, F., Upfal, E., &amp; Raphael, B. J. (2011). Algorithms for detecting significantly mutated pathways in cancer. Journal of computational biology : a journal of computational molecular cell biology, 18(3), 507-522. https://doi.org/10.1089/cmb.2010.0265 Qi, Y., Suhail, Y., Lin, Y. Y., Boeke, J. D., &amp; Bader, J. S. (2008). Finding friends and enemies in an enemies-only network: a graph diffusion kernel for predicting novel genetic interactions and co-complex membership from yeast genetic interactions. Genome research, 18(12), 1991-2004. https://doi.org/10.1101/gr.077693.108 What Are Single Nucleotide Polymorphisms (SNPs)? (n.d.). Retrieved from https://medlineplus.gov/genetics/understanding/genomicresearch/snp/ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= fc9bc3389f10c78caadaa9d56096928a52c78f21 "]]
