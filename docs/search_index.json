[["index.html", "MATH 479 Network Science Project Preface", " MATH 479 Network Science Project Zhaoheng Li and Zuofu Huang, Fall 2020 Macalester College Preface Hello! Welcome to our final project of Network Science! This bookdown is a work in progress, and please check back early and often (as much as people do to their Github code). Feel free to contact us if you have any questions! Now that we are in the realm of networks, we feel compelled to motivate our project with an xkcd comic related to networks. Credit to xkcd: https://xkcd.com/350/ "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction We are motivated by existing genetic association studies that find the correlation between certain diseases/traits and genetic variants (SNP mutations). We wonder if network analysis can be utilized in the process of association studies. Later, we came across the paper named Network Analysis of GWAS data (Leiserson et. al, 2013), where we first saw the connection made between genetics and network science. This motivates our attempt of finding genetic pathway interactions for a certain disease/trait. Intuitively, we would like to think of the simplified scenario: a certain disease can be caused by several genetic pathways. Suppose we have \\(n\\) SNP locations previously identified as related to the disease, and \\(k\\) subsets among the SNP locations that in combination cause the disease (\\(k &lt; n\\)). Our goal is to simulate data that aligns with the proposed setting, and use network science tools to identify these pathway interactions (pretending that we did not know the underlying true subsets). This process aims at testing the validity of the network science tool we propose. Looking forward, we would like to test how the tool behaves when the dataset we simulate contains genetic information for two diseases: we wonder if the algorithm is capable of picking up pathway interaction patterns for both diseases. "],["initial-steps.html", "Chapter 2 Initial Steps 2.1 Simulate original data 2.2 Sample mutations for patients at SNP locations 2.3 Sample mutations for non-patients at SNP locations 2.4 Variants at non-SNP locations 2.5 Screening 2.6 Marginal Regression 2.7 Discussion", " Chapter 2 Initial Steps Our initial thought was that Genome-Wide Association Studies (GWAS) data is widely available 2.1 Simulate original data We start by creating the dataset. Everyone row is set to the reference level first (i.e. there is no variant). n &lt;- 500 n_disease &lt;- 100 loci &lt;- 1000 locus_length &lt;- 200 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = loci*locus_length, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = loci * locus_length,byrow = TRUE)) SNP_location &lt;- sample(1:(loci*locus_length), size = 50, replace = FALSE) reference_level_SNP_location &lt;- reference[SNP_location] 2.2 Sample mutations for patients at SNP locations We then sample mutations at SNP locations who were categorized at patients. disease_people_row_number &lt;- sample(1:500, 100, replace = FALSE) combo_number &lt;- 15 SNP_number &lt;- sample(1:6, combo_number, replace = TRUE) disease_combo &lt;- list() for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) #helper functions for decomposition. helper2 &lt;- function(char){ other_set &lt;- setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;G&quot;,&quot;C&quot;),char) return(sample(other_set,1)) } helper3 &lt;- function(char, p = 0.15){ random &lt;- runif(1) if (random &lt;= (1-3*p)){ return(char) } else if (random &lt;= 1-2*p){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[1]) } else if (random &lt;= (1-p)){ return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[2]) } else { return(setdiff(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;),char)[3]) } } # For patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper2(reference_level_SNP_location[index[j]]) } # non-disease-related SNP mutations non_forced_index &lt;- setdiff(1:50, index) for (k in 1:length(non_forced_index)){ reference_level_SNP_location_copy[non_forced_index[k]] &lt;- helper3(reference_level_SNP_location[non_forced_index[k]],0.15) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy } 2.3 Sample mutations for non-patients at SNP locations We then hypothesize that given a common condition, non-patients are also more likely to have mutations at the SNP locations than at most other locations (e.g. those locations that make human human). # For those who are not set to have disease first (400) # Loop over 50 genes, each one has some possibility to mutate. (More likely than the other nucleotides on the genome) non_disease_row_number &lt;- setdiff(1:500,disease_people_row_number) for (i in non_disease_row_number){ for (j in SNP_location) data[i,j] &lt;- helper3(data[i,j],0.05) } 2.4 Variants at non-SNP locations The next step is simulating random noise at non-SNP locations to better mimic properties of gene mutations in real life. potential_SNP_places &lt;- SNP_location potential_random_change_sites &lt;- setdiff(1:(loci*locus_length),SNP_location) for (i in 1:n){ random_locus &lt;- sample(potential_random_change_sites, size = (loci*locus_length/1000), replace = FALSE) # definitely change for(j in random_locus){ data[i,j] &lt;- helper2(data[i,j]) potential_SNP_places &lt;- c(potential_SNP_places, random_locus) } } potential_SNP_places &lt;- unique(potential_SNP_places) 2.5 Screening With the mutations that non-patients had at SNP locations, some of them may fall into the “disease” status. We then performed a round of screening for 400 people who were initially categorized without the disease. Surprisingly, we found that a large number of people fall into the “disease” status. We were surprised for two reasons: The probability of mutations at each location is low. Even if many mutations happen for someone, a right “combination of pathways” is needed to achieve the “disease” status, which happens more often than estimated. # Do a round of screening for 400 people who did not initially have the disease NewPatient &lt;- c() for (i in non_disease_row_number){ MutatedSNP &lt;- c() for(j in SNP_location){ if(isMutated(i,j)){ MutatedSNP &lt;- c(MutatedSNP,j) } } for(k in 1:15){ if(all(disease_combo[[k]] %in% MutatedSNP)){ causalPathway &lt;- c() for(position in disease_combo[[k]]){ causalPathway = c(causalPathway,helper2(reference[position])) } if(all(data[i,position] == causalPathway)){ NewPatient &lt;- c(NewPatient,i) break } } } } disease_row_final &lt;- c(disease_people_row_number, NewPatient) disease_status_vector &lt;- rep(FALSE, 500) for (i in 1:500){ if (i %in% disease_row_final){ disease_status_vector[i] &lt;- TRUE } } 2.6 Marginal Regression Once we have simulated potential variants for everyone at every location, we find all places that at least one person has a variation at, select the places and fit a marginal regression at each location against the disease status. for (i in potential_SNP_places){ reference_level_here &lt;- reference[i] for (j in 1:n){ if (data[j,i] == reference_level_here){ data[j,i] &lt;- TRUE } else { data[j,i] &lt;- FALSE } } } subdata &lt;- data[,potential_SNP_places] isMutated &lt;- function(person,position){ if(data[person,position] == reference[position] ){ return(FALSE) } else{ return(TRUE) } } for (i in potential_SNP_places){ summary(lm(disease_status_vector ~ data[,i])) } 2.7 Discussion Problems with this approach, as we realized later, were that: We assumed genetic variants were the only reason people caused the disease, which was almost never the case. People who were initially categorized as non-patients and later changed their status are more than we expected. This casts doubt on the necessity of pre-determining the number of patients (100 in this case). Our approach was not fully supported by pre-existing literature. We pasted pieces of several literature into this approach. The probability of mutations at each location was also not documented. When we are simulating random variants, we set the number of changes to be size = (loci*locus_length/1000) as we believed the average probability of SNP is 1/1000. However, this is faulty because the size was fixed at the expected value of the number of mutation sites, without allowing any difference across individuals. Let \\(\\text{X = number of variants}\\) and \\(\\text{n = number of locations}\\). \\(X\\) follows the distribution: \\(X \\sim Bin(n,p)\\). However, \\(X\\) can vary as we draw from the Binomial distribution. With the reasons above, we keep digging into the literature and tested potential alternatives. "],["progress-and-revision.html", "Chapter 3 Progress and Revision 3.1 Rationale 3.2 Updated Code", " Chapter 3 Progress and Revision 3.1 Rationale When we found out that only SNP locations can be categorized as significant and other loci are exclusively “non-significant”, we realized that we are getting too far into simulation. Although it seemed that every step we take is justified, the simulated data seem unrealistic and overfitting for our scenario. As we were conduting a more extensive literature review process in the hope of shedding light on our next simulation steps, we came across the paper Discovery of Mutated Subnetworks Associated with Clinical Data in Cancer (Vandin et. al, 2012). Section 3.1 of the paper contains a description of how the data is simulated in a slightly different setting. There are a few notable changes that we implemented in the Progress and Revision section. We argue that a common disease can be caused by both genetic variants and external environmental factors, as opposed to the genetic variations alone in our previous simulations. Therefore, we can pre-determine the number of people whose diseases are caused by genetic factors (as the paper suggested, 20% of people who carry the disease). The value of \\(p\\) is determined by the biological background that on average the probability of having a mutation at each location is \\(1/1000\\), as described in “What Are Single Nucleotide Polymorphisms (SNPs)?” (n.d.). For people whose diseases are caused by genetic factors: the probability of mutations at each of the other locations has a probability of \\(p = 1/1000\\). For people whose diseases are caused by non-genetic factors: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For people who do not have the disease: the probability of mutations at each of the non-SNP locations has a probability of \\(p = 1/1000\\). For the purpose of the simulation, we combine the group of people whose disease are caused by non-genetic factors and the group of people who do not carry the disease. Suppose we have a total of 500 people, half of which do not carry the disease. Then the total number of people whose disease are caused by genetic factors is 10% of the total population, as seen in n_disease &lt;- 0.1n in the Update Code section below. We determine that there are 4 combinations of genetic pathways that cause the disease (which is much more realistic than 15 pathways). Each of the pathway contains a random group of 4-5 variants chosen from 15 SNP locations. The variant could be present in more than one pathway or none of the pathways. We replace the multiplication of loci and locus_length with a total positions of 3000. We argue that reducing the number of loci at first does not change our inference process. As we test the validity of the approach, we then have the freedom of increasing the dimension (column) of the dataset or incorporating another disease/trait and the corresponding genetic pathways in our analysis. 3.2 Updated Code n &lt;- 500 n_disease &lt;- n*0.1 total_position &lt;- 3000 reference &lt;- sample(c(&quot;A&quot;,&quot;T&quot;,&quot;C&quot;,&quot;G&quot;), size = total_position, replace = TRUE) data &lt;- data.frame(matrix(data = rep(reference, n), nrow = n, ncol = total_position,byrow=TRUE)) disease_people_row_number &lt;-seq(1,n_disease) non_disease &lt;- seq((n_disease+1),n) combo_number &lt;- 4 disease_combo &lt;- list() SNP_number &lt;- sample(4:5, combo_number, replace = TRUE) SNP_location &lt;- sample(1:total_position, 15, replace = FALSE) for (i in 1:length(SNP_number)){ disease_combo[[i]] &lt;- sample(SNP_location, size = SNP_number[i], replace = FALSE) } reference_level_SNP_location &lt;- reference[SNP_location] disease_people_SNP_locations &lt;- list() which_combo_they_get &lt;- sample(1:combo_number, n_disease, replace = TRUE) helper &lt;- function(char){ return(sample(setdiff(c(&quot;A&quot;,&quot;C&quot;,&quot;T&quot;,&quot;G&quot;),char),1)) } # function to mutate positions not in the identified pathways mutater &lt;- function(vec,non_position){ mutated &lt;- c() for (i in 1:length(vec)){ if (! i %in% non_position){ rand &lt;- runif(1) if (rand &lt;= 10^{-3}){ vec[i] &lt;- helper(vec[i]) mutated &lt;- c(mutated, i) } } } return(list(vec,mutated)) } # all mutated positions mutated_position &lt;- SNP_location # keep track of mutated positions for each subject # to record co-occurrence frequency of mutations # For causal-pathway-related patients for (i in 1:n_disease){ # disease-related SNP mutations first reference_level_SNP_location_copy &lt;- reference_level_SNP_location thiscombo &lt;- disease_combo[[which_combo_they_get[i]]] index &lt;- match(thiscombo, SNP_location) for (j in 1:length(index)){ reference_level_SNP_location_copy[index[j]] &lt;- helper(reference_level_SNP_location[index[j]]) } data[disease_people_row_number[i],][SNP_location] &lt;- reference_level_SNP_location_copy # random change mutated_result &lt;- mutater(data[i,],thiscombo) data[i,] &lt;- mutated_result[[1]] # update the list of mutated positions for person i #mutatedLst[[i]] = c(thiscombo,mutated_result[[2]]) # update the list of all positions that mutated mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } # for everyone else for (k in (n_disease+1):n){ # update mutated positions mutated_result &lt;- mutater(data[k,], SNP_location) data[k,] &lt;- mutated_result[[1]] mutated_position &lt;- c(mutated_position, mutated_result[[2]]) } mutated_position &lt;- unique(mutated_position) # Delete the locations among the 15 pre-identified locations that are not selected to be part of a causal pathway del &lt;- c() for(p in mutated_position){ count &lt;- 0 if(all(data[,p]==reference[p])){ del &lt;- c(del,p) } } mutated_position &lt;- setdiff(mutated_position,del) # Create a subset of the data for all positions with at least one mutation for(position in mutated_position){ # return true if a mutation happens at the position data[,position] &lt;- !(data[,position]==reference[position]) } sub_data &lt;- data[,mutated_position] position &lt;- colnames(sub_data) Create the adjacency matrix A that contains all positions where there is at least one mutation across all subjects. A = matrix(0,length(mutated_position),length(mutated_position)) rownames(A) = colnames(sub_data) colnames(A) = colnames(sub_data) for(i in 1:nrow(sub_data)){ count = sum(sub_data[i,]==TRUE) if(count&gt;=2){ loc = which(as.logical(as.vector(sub_data[i,])),TRUE) pairs_mat = combn(loc,2) for(j in 1:ncol(pairs_mat)){ r = pairs_mat[1,j] c = pairs_mat[2,j] A[r,c] = A[r,c]+1 } } } A = as.matrix(forceSymmetric(A,&quot;U&quot;)) Calculate the degree of the adjacency matrix. We can understand more of the matrix by calculating the average degree. deg = rowSums(A) "],["network-construction.html", "Chapter 4 Network Construction 4.1 Network Construction Process 4.2 Analysis 4.3 Centrality Measures Report", " Chapter 4 Network Construction 4.1 Network Construction Process Below are the steps for calculating the “gene score” of each location that quantifies the degree of association between a base position and the disease/trait of interest. A higher score means a stronger association. For each position \\(g\\), we performed marginal regression and obtain a p-value, \\(p_g\\). Every position then is assigned a score \\(\\sigma(g) = -2log(p_g)\\) (Vandin et al., 2012). Two positions share an edge if they occur together, and the edge weight is their co-occurrence number. # record p values for each position mutations_pVal = c() disease_status_vector = c(rep(1,n/2),rep(0,n/2)) for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_vector&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) mutations_pVal = c(mutations_pVal,summary(model)$coefficient[,4][2]) } # compute score for each mutated position mutations_score &lt;- -2*log(mutations_pVal) edges = melt(A) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;%mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type, Weight) %&gt;% filter(Weight != 0) nodes = as.data.frame(colnames(sub_data))%&gt;%mutate(Lable= colnames(sub_data)) colnames(nodes) = c(&quot;Id&quot;,&quot;Lable&quot;) A.dat = as.data.frame(A) 4.2 Analysis After revising our simulation methodology, we simulated using 3000 base positions and 500 samples to obtain the following graphs. 12 of the 15 previously identified SNP locations are chosen to be part of at least one genetic pathway: X520, X521, X526, X1237, X1320, X1533, X1627, X2075, X2106, X2699, X2766, and X2881. These 12 effective SNP locations form 4 causal pathways that lead to the disease: X2699, X1320, X520, X2881 X2766, X1237, X2075, X521, X526 X526, X2766, X2106, X2075, X1533 X2699, X521, X2881, X1533, X1627 After a round of random mutations, we obtain 1187 mutated positions in total. This gives us an undirected weighted graph with 1187 nodes and 2838 edges, which produces an average degree of4.78. There is a single major component containing roughly 65% of its nodes. Expectedly, all causal pathways identified beforehand exist within this major connected component. Figure 4.1 shows the full graph, while Figure 4.2 shows its single major component. Using a resolution of 1, we obtained 25 modularity classes within the major connected component. The 12 selected positions are divided between two largest modules. \\[\\text{Figure} \\; 4.1 :\\; \\text{Full Network of Mutated Gene Base Positions}\\] \\[\\text{Figure} \\; 4.2 :\\; \\text {Modularity Class Decomposition within the Major Connected Component, with Nodes Sized According to Closeness Centrality}\\] 4.3 Centrality Measures Report Table 4.1 reports the top 12 nodes ranked by their degrees, eigenvector centrality, closeness centrality and betweeness centrality. The 12 effective disease-related positions selected are exactly the top 12 nodes with the greatest degrees and eigenvector centrality. This might be a result of the high degree of inter-connectivity among these positions. By comparison, the \\(8^{th}\\), \\(10^{th}\\), and \\(12^{th}\\) nodes with the most closeness centrality are random variations, while 8 of the top 12 nodes with the greatest betweenness centrality are random variations. dt = tab1 pathwaySNP = tab1$Degree dt$Degree = cell_spec(dt$Degree, color = ifelse(dt$Degree %in%pathwaySNP, &quot;red&quot;, &quot;blue&quot;)) dt$`Eigenvector Centrality` = cell_spec(dt$`Eigenvector Centrality`,color= ifelse(dt$`Eigenvector Centrality` %in%pathwaySNP, &quot;red&quot;, &quot;blue&quot;)) dt$`Closeness Centrality` = cell_spec(dt$`Closeness Centrality`, color = ifelse(dt$`Closeness Centrality` %in%pathwaySNP, &quot;red&quot;, &quot;blue&quot;)) dt$`Betweeness Centrality` = cell_spec(dt$`Betweeness Centrality`, color = ifelse(dt$`Betweeness Centrality` %in%pathwaySNP, &quot;red&quot;, &quot;blue&quot;)) kbl(dt, escape = F) %&gt;% kable_styling() Rank Degree Eigenvector Centrality Closeness Centrality Betweeness Centrality 1 X2699 X2881 X2881 X2881 2 X2881 X2699 X2699 X2699 3 X521 X521 X1533 X1533 4 X2075 X1533 X520 X807 5 X2766 X2075 X1320 X2083 6 X526 X2766 X521 X2438 7 X1533 X526 X2075 X2251 8 X520 X520 X2766 X1301 9 X1320 X1320 X526 X1806 10 X1237 X1627 X39 X1739 11 X1627 X1237 X1627 X521 12 X2106 X2106 X1889 X571 dt %&gt;% kbl() %&gt;% kable_styling(fixed_thead = T) Rank Degree Eigenvector Centrality Closeness Centrality Betweeness Centrality 1 &lt;span style=\" color: red !important;\" &gt;X2699&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2881&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2881&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2881&lt;/span&gt; 2 &lt;span style=\" color: red !important;\" &gt;X2881&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2699&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2699&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2699&lt;/span&gt; 3 &lt;span style=\" color: red !important;\" &gt;X521&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X521&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1533&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1533&lt;/span&gt; 4 &lt;span style=\" color: red !important;\" &gt;X2075&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1533&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X520&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X807&lt;/span&gt; 5 &lt;span style=\" color: red !important;\" &gt;X2766&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2075&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1320&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X2083&lt;/span&gt; 6 &lt;span style=\" color: red !important;\" &gt;X526&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2766&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X521&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X2438&lt;/span&gt; 7 &lt;span style=\" color: red !important;\" &gt;X1533&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X526&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2075&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X2251&lt;/span&gt; 8 &lt;span style=\" color: red !important;\" &gt;X520&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X520&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2766&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X1301&lt;/span&gt; 9 &lt;span style=\" color: red !important;\" &gt;X1320&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1320&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X526&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X1806&lt;/span&gt; 10 &lt;span style=\" color: red !important;\" &gt;X1237&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1627&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X39&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X1739&lt;/span&gt; 11 &lt;span style=\" color: red !important;\" &gt;X1627&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1237&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X1627&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X521&lt;/span&gt; 12 &lt;span style=\" color: red !important;\" &gt;X2106&lt;/span&gt; &lt;span style=\" color: red !important;\" &gt;X2106&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X1889&lt;/span&gt; &lt;span style=\" color: blue !important;\" &gt;X571&lt;/span&gt; "],["enhanced-influence-models.html", "Chapter 5 Enhanced Influence Models 5.1 Graph Diffusion Kernel 5.2 Enhanced Influence Model 5.3 Code", " Chapter 5 Enhanced Influence Models 5.1 Graph Diffusion Kernel Here we imagine that the importance of nodes flows along edges. Initially, query nodes are selected to serve as sources where fluid is pumped in at a constant rate which then diffuses through the network. In addition, we assume that fluid leaks out of each node at a constant rate \\(\\gamma\\). Intuitively, large \\(\\gamma\\) means faster rate of loss and therefore shorter diffusive paths. Essentially, the paths reflects diffusion of random walkers from a source. At equilibrium, there is no net flow in the entire network. The more interaction a node has with the query nodes, the more fluid it will contain at the equilibrium (Qi et al., 2008). Following the procedure in previous literature (Vandin, Upfal, and Raphael, 2011), we set \\(\\gamma = 5\\), which is approximately the average degree of a node in our network. Mathematically,let \\(u(t)\\) denotes the unit step function where \\[u(t) = \\begin{cases}0 \\;\\text{ if }\\;t&lt;0\\\\1 \\;\\text{ if }\\;t&gt;0 \\end{cases},\\] and \\(b_i = 1\\) if i is the source node of interest while \\(b_i = 0\\) otherwise. The amount of fluid contained by node \\(i\\) at time t is \\(x_i(t)\\) is governed by the flow in and out of it, \\[\\frac{d}{dt}x_i(t) = \\sum_j A_{ij}x_j(t)-\\sum_jA_{ji}x_i(t)-\\gamma x_i(t)\\] As \\(t\\to \\infty\\), the fluid distribution approaches to its equilibrium distribution at which the influence of node \\(i\\) to other nodes is measured by \\[L_\\gamma^{-1}\\vec{b_i}\\] where \\(\\vec{b_i}\\) is the standard basis with 1 at its \\(i^{th}\\) entry. Here, \\(L_\\gamma = L+\\gamma I = S-A+\\gamma I\\) is the shifted graph Laplacian by \\(\\gamma\\) where \\(S\\) is the diagonal matrix whose diagonal entries are the corresponding degrees. In practice, we normalize A symmetrically by \\(S^{-\\frac{1}{2}}AS^{-\\frac{1}{2}}\\) such that the edge weights between two nodes are normalized by the degrees and replace \\(S\\) correspondingly to obtain the Laplacian (Qi et al. 2008). Here, the \\(ij\\) entry of \\(L_\\gamma^{-1}\\) gives the influence of \\(j\\) on \\(i\\), which may or may not equal to the \\(ji\\) entry of \\(L_\\gamma^{-1}\\). To better interpret the result, we define the mutual influence between i and j to be \\(\\tilde{i}(i,j) = \\min(L_\\gamma^{-1}[i,j],L_\\gamma^{-1}[j,i])\\). (Vandin, Upfal, and Raphael, 2011) 5.2 Enhanced Influence Model Enhanced Influence Model is an efficient algorithm to identify a significantly mutated subnetwork with respect to gene interactions. (Vandin, Upfal, and Raphael, 2011) Let \\(\\sigma_i\\) be a score for gene \\(i\\), as measured by \\(\\sigma_i = -2\\log(p_i)\\) where \\(p_i\\) is the p-value obtained from marginal regression. For each pair of genes (\\(i\\),\\(j\\)), their mutual interaction is measured by \\(w(i,j) = \\max(\\sigma_i,\\sigma_j)*\\tilde{i}(i,j)\\) (Vandin et al., 2011). Next, we remove all edges with weights smaller than a threshold \\(\\delta\\) to obtain a subgraph. The connected components remained are candidates for genetic pathways. The code below shows how we construct the enhanced influence model from scratch. # normalize A A_normalized &lt;- matrix(0,nrow(A),nrow(A)) for(i in 1:(nrow(A)-1)){ for(j in i:nrow(A)){ if(deg[i]!=0 &amp;&amp; deg[j]!=0){ A_normalized[i,j] &lt;- A[i,j]/sqrt(deg[i]*deg[j]) } } } A_normalized &lt;- forceSymmetric(A_normalized,&quot;U&quot;) A_normalized &lt;- as.matrix(A_normalized) # normalize the corresponding degree matrix S S_normalized &lt;- diag(rowSums(A_normalized)) gamma &lt;- 5 L_gamma &lt;- S_normalized+diag(gamma,nrow(A))-A_normalized inv_L_gamma &lt;- solve(L_gamma) # compute symmetric importance score using Enhanced Influence Model W &lt;- matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W[i,j] &lt;- min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(mutations_score[i],mutations_score[j]) } } # helper function to remove cold_edge removeColdEdge &lt;- function(mat,W,delta){ hotnet &lt;- mat for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ if(W[i,j]&lt;delta){ hotnet[i,j] = 0 } } } return(hotnet) } Hotnet &lt;- removeColdEdge(A_normalized,W,0.04) Hotnet &lt;- as.matrix(forceSymmetric(Hotnet,&quot;U&quot;)) colnames(Hotnet) &lt;- position rownames(Hotnet) &lt;- position HotEdges &lt;- melt(Hotnet) %&gt;% rename(Source = Var1, Target = Var2, Weight = value) %&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0) %&gt;% select(-Weight) edges.copy &lt;- edges edges.copy &lt;- edges.copy %&gt;% select(Source,Target) colnames(edges.copy) &lt;- c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) # get a list of connected components clu &lt;- components(g) res &lt;- groups(clu) getNumComp &lt;- function(edges,nodes,s){ edges.copy = edges edges.copy = edges.copy%&gt;%select(Source,Target) colnames(edges.copy) = c(&quot;from&quot;,&quot;to&quot;) g &lt;- graph_from_data_frame(edges.copy, directed=FALSE, vertices=nodes) clu &lt;- components(g) res &lt;- groups(clu) count &lt;- 0 for(i in 1:length(res)){ if(length(res[[i]]) &gt;= s){ count = count+1 } } return(count) } 5.2.1 Determine Value for Cold-Edge Threshold \\(\\delta\\) We start with simulating 50 datasets under \\(H_0^P\\) by permuting observed disease status. (Vandin et. al, 2012) Then for a small value of \\(s\\), where often \\(s \\in \\{3,4,5\\}\\), we choose the first \\(\\delta\\) that gives the largest number of subnetworks of size at least \\(s\\). Given the size of our network, we use \\(s = 3\\). The \\(\\delta\\) value is \\(0.02\\). Since increasing \\(\\delta\\) gives us more conservative criteria, we also consider the following values: \\(1.5\\delta = 0.03, 2\\delta = 0.04, 3\\delta = 0.06, 4\\delta = 0.08\\). For different \\(\\delta\\) values, we construct graphs for the major component in each network. In the ideal scenario, we expect that the major component contains and only contains the SNP locations involved in genetic pathways. This is one way that we could use to evaluate our results. Intuitively, nodes get a lot bigger as \\(\\delta\\) increases. This is because we have fewer nodes in the major component. \\[\\text{Figure 5.1(a): Major component of the network of mutated genes when delta = 0.02}\\] \\[\\text{Figure 5.1(b): Major component of the network of mutated genes when delta = 0.03}\\] \\[\\text{Figure 5.1(c): Major component of the network of mutated genes when delta = 0.04}\\] \\[\\text{Figure 5.1(d): Major component of the network of mutated genes when delta = 0.06}\\] \\[\\text{Figure 5.1(e): Major component of the network of mutated genes when delta = 0.0}\\] We found that at \\(\\delta = 0.04\\) and \\(\\delta= 0.06\\), the major component both contains precisely the 12 SNP locations that were part of at least one pathway interaction combination. To determine which one of the two is better, we go back to the four original pathways and evaluate their quality. It seems that the major component more accurately describes the truth when \\(\\delta = 0.04\\), as presented below. \\[\\text{Figure 5.2: Modularity Class Breakdown within the Major Component when delta = 0.04}\\] 5.2.2 Alternative Situation In the previous section, we find that our method is confused about which modularity class a certain node belongs to. We hypothesize that this may be due to that the node makes up more than one combination of pathway interactions. We wonder if the problem will arise when each mutation only contributes to one pathway combination (denoted as Scenario B). If the problem universally happens, we need to analyze its cause. We repeated the process, with a twist in the construction of the original dataset. The full network of mutated genes looks like this: \\[\\text{Figure 5.3: Figure Full Network of Mutated Genes under Scenario B}\\] The major component in the network is as follows: \\[\\text{Figure 5.4: Modularity Class Breakdown within the Major Component under Scenario B}\\] Our modularity class breakdown exactly replicates the combinations of pathways that cause the disease. This supplies proof for the validity of our method. 5.3 Code Below is the code that supports our work in this chapter. disease_status_mat &lt;- matrix(NA,50,500) for(i in 1:50){ disease_status_mat[i,] &lt;- permute(disease_status_vector) } pVal.lst &lt;- list() for(k in 1:50){ res &lt;- c() for (i in 1:length(position)){ outcome &lt;- &quot;disease_status_mat[k,]&quot; variable &lt;- position[i] f &lt;- as.formula(paste(outcome, paste(variable), sep = &quot; ~ &quot;)) model &lt;- lm(f, data = sub_data) res &lt;- c(res,summary(model)$coefficient[,4][2]) pVal.lst[[k]] = res } } score.lst = list() for(k in 1:50){ score.lst[[k]] = -2*log(pVal.lst[[k]]) } W.lst = list() for(k in 1:50){ W.lst[[k]] = matrix(NA, nrow(A),ncol(A)) for(i in 1:(nrow(A)-1)){ for(j in (i+1):nrow(A)){ W.lst[[k]][i,j] = min(inv_L_gamma[i,j],inv_L_gamma[j,i])*max(score.lst[[k]][i],score.lst[[k]][j]) } } } aveNumComp_s &lt;- function(delta, s=3){ # list of adjacency matrices for HotNet for 50 datasets under the null hypothesis # under the given threshold delta Hotnet.lst = list() for(k in 1:10){ Hotnet.lst[[k]] = removeColdEdge(A_normalized,W.lst[[k]],delta) Hotnet.lst[[k]] = as.matrix(forceSymmetric(Hotnet.lst[[k]],&quot;U&quot;)) } HotEdges.lst = list() for(k in 1:10){ colnames(Hotnet.lst[[k]]) = position rownames(Hotnet.lst[[k]]) = position HotEdges.lst[[k]]= melt(Hotnet.lst[[k]]) %&gt;% rename(Source = Var1, Target = Var2, Weight = value)%&gt;% mutate(Type = &quot;Undirected&quot;) %&gt;% select(Source, Target, Type,Weight) %&gt;% filter(Weight != 0)%&gt;%select(-Weight) } numComp_s = rep(0,10) for(k in 1:10){ numComp_s[k] = getNumComp(HotEdges.lst[[k]],nodes,s) } return(mean(numComp_s)) } x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=3) ## [1] 99.3 115.9 48.3 8.0 3.1 1.2 1.2 0.0 0.0 x &lt;- seq(0.01,0.09, 0.01) sapply(x, aveNumComp_s,s=2) ## [1] 160.5 215.2 147.3 69.9 61.9 56.1 3.9 2.0 1.3 "],["discussion-and-future-work.html", "Chapter 6 Discussion and Future Work 6.1 What did we achieve? 6.2 Limitations 6.3 Future Work", " Chapter 6 Discussion and Future Work 6.1 What did we achieve? The most exciting part of this project to us is using network science to solve real-life problems. Genetics is such an complex topic and affects every part of who we are. Given how chemistry works in our body, it is hard to imagine that we could accurately quantify how genes interact with each other. But we are excited to learn that with some basic assumptions, one could have some predicting power with mathematical tools, even though we have to leave out many details in our modeling process. The takeaway is that we are able to model how pathway interactions cause diseases and use network science tools to detect such pathways. Our assumption states that diseases/traits can be caused by a combination of mutations at SNP locations, and one mutation may be involved in multiple combinations. This poses an inherent challenge for network analysis: it is hard to classify which modularity class that such mutations should belong to. However, we present that our method perfectly classifies different pathway interactions if one mutation could only exist in one combination. 6.2 Limitations A major limitation, as discussed above, is the adherence to biological facts. It is not feasible to exactly replicate the complex biochemical processes along the DNA sequence, and thus our assumptions bear the risk of not representing the reality. During our analysis, we first pre-determined which combinations of variants along the genome could lead to the disease/trait. However, we do not know the underlying true combinations of pathway interactions in real life. When implementing our algorithm in a more realistic setting, we may have difficulty interpreting the validity of the result. For example, in Chapter 4, we see that our method perfectly detects the combination “X2699, X1320, X520, X2881”, and yields slight discrepancies in other combinations. Thus, it is important to test the algorithm in different settings and better understand how the results may be impacted. In addition, many inputs of our method are chosen relatively arbitrarily based on existing literature. We attempted many different values for variables including total SNP locations and the number of combinations. It is, however, important to note that we could not test all potential values for all variables. We would like to understand changes in our algorithm’s accuracy if we have a larger number of SNP locations or more possible combinations etc. 6.3 Future Work Given the time constraint, many interesting problems and extensions remain to be explored and discussed. One extension that we mentioned earlier is how we can incorporate two disease/traits and their corresponding pathways and check if our method accurately detects both pathways under a different setting of noises. In addition, there may be other tools designed for our setting, which may incorporate work from network science, statistical genetics or computational biology. "],["references.html", "Chapter 7 References", " Chapter 7 References Leiserson, M. D., Eldridge, J. V., Ramachandran, S., &amp; Raphael, B. J. (2013). Network analysis of GWAS data. Current opinion in genetics &amp; development, 23(6), 602-610. https://doi.org/10.1016/j.gde.2013.09.003 Vandin, F., Clay, P., Upfal, E., &amp; Raphael, B. J. (2012). Discovery of mutated subnetworks associated with clinical data in cancer. Pacific Symposium on Biocomputing. Pacific Symposium on Biocomputing, 55-66. Vandin, F., Upfal, E., &amp; Raphael, B. J. (2011). Algorithms for detecting significantly mutated pathways in cancer. Journal of computational biology : a journal of computational molecular cell biology, 18(3), 507-522. https://doi.org/10.1089/cmb.2010.0265 Qi, Y., Suhail, Y., Lin, Y. Y., Boeke, J. D., &amp; Bader, J. S. (2008). Finding friends and enemies in an enemies-only network: a graph diffusion kernel for predicting novel genetic interactions and co-complex membership from yeast genetic interactions. Genome research, 18(12), 1991-2004. https://doi.org/10.1101/gr.077693.108 What Are Single Nucleotide Polymorphisms (SNPs)? (n.d.). Retrieved from https://medlineplus.gov/genetics/understanding/genomicresearch/snp/ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= fc9bc3389f10c78caadaa9d56096928a52c78f21 "]]
